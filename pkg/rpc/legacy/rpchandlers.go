// generated by go run github.com/l0k18/pod/pkg/rpc/legacy/genapi/gen.go; DO NOT EDIT
//
//go:generate go run genapi/genapi.go genapi/log.go

package legacy

import (
	"io"
	"net/rpc"
	"time"

	"github.com/l0k18/pod/pkg/rpc/btcjson"
	"github.com/l0k18/pod/pkg/wallet"
	"github.com/l0k18/pod/pkg/wallet/chain"
)

// API stores the channel, parameters and result values from calls via the channel
type API struct {
	Ch     interface{}
	Params interface{}
	Result interface{}
}

// CAPI is the central structure for configuration and access to a net/rpc API access endpoint for this RPC API
type CAPI struct {
	Timeout time.Duration
	quit    chan struct{}
}

// NewCAPI returns a new CAPI 
func NewCAPI(quit chan struct{}, timeout ...time.Duration) (c *CAPI) {
	c = &CAPI{quit: quit}
	if len(timeout) > 0 {
		c.Timeout = timeout[0]
	} else {
		c.Timeout = time.Second * 5
	}
	return
}

// Wrappers around RPC calls

type CAPIClient struct {
	*rpc.Client
}

// NewCAPIClient creates a new client for a kopach_worker. Note that any kind of connection can be used here, other than the
// StdConn
func NewCAPIClient(conn io.ReadWriteCloser) *CAPIClient {
	return &CAPIClient{rpc.NewClient(conn)}
}

type (
	// None means no parameters it is not checked so it can be nil
	None struct{}
	// AddMultiSigAddressRes is the result from a call to AddMultiSigAddress
	AddMultiSigAddressRes struct {
		Res *string
		Err error
	}
	// CreateMultiSigRes is the result from a call to CreateMultiSig
	CreateMultiSigRes struct {
		Res *btcjson.CreateMultiSigResult
		Err error
	}
	// CreateNewAccountRes is the result from a call to CreateNewAccount
	CreateNewAccountRes struct {
		Res *None
		Err error
	}
	// HandleDropWalletHistoryRes is the result from a call to HandleDropWalletHistory
	HandleDropWalletHistoryRes struct {
		Res *string
		Err error
	}
	// DumpPrivKeyRes is the result from a call to DumpPrivKey
	DumpPrivKeyRes struct {
		Res *string
		Err error
	}
	// GetAccountRes is the result from a call to GetAccount
	GetAccountRes struct {
		Res *string
		Err error
	}
	// GetAccountAddressRes is the result from a call to GetAccountAddress
	GetAccountAddressRes struct {
		Res *string
		Err error
	}
	// GetAddressesByAccountRes is the result from a call to GetAddressesByAccount
	GetAddressesByAccountRes struct {
		Res *[]string
		Err error
	}
	// GetBalanceRes is the result from a call to GetBalance
	GetBalanceRes struct {
		Res *float64
		Err error
	}
	// GetBestBlockRes is the result from a call to GetBestBlock
	GetBestBlockRes struct {
		Res *btcjson.GetBestBlockResult
		Err error
	}
	// GetBestBlockHashRes is the result from a call to GetBestBlockHash
	GetBestBlockHashRes struct {
		Res *string
		Err error
	}
	// GetBlockCountRes is the result from a call to GetBlockCount
	GetBlockCountRes struct {
		Res *int32
		Err error
	}
	// GetInfoRes is the result from a call to GetInfo
	GetInfoRes struct {
		Res *btcjson.InfoWalletResult
		Err error
	}
	// GetNewAddressRes is the result from a call to GetNewAddress
	GetNewAddressRes struct {
		Res *string
		Err error
	}
	// GetRawChangeAddressRes is the result from a call to GetRawChangeAddress
	GetRawChangeAddressRes struct {
		Res *string
		Err error
	}
	// GetReceivedByAccountRes is the result from a call to GetReceivedByAccount
	GetReceivedByAccountRes struct {
		Res *float64
		Err error
	}
	// GetReceivedByAddressRes is the result from a call to GetReceivedByAddress
	GetReceivedByAddressRes struct {
		Res *float64
		Err error
	}
	// GetTransactionRes is the result from a call to GetTransaction
	GetTransactionRes struct {
		Res *btcjson.GetTransactionResult
		Err error
	}
	// GetUnconfirmedBalanceRes is the result from a call to GetUnconfirmedBalance
	GetUnconfirmedBalanceRes struct {
		Res *float64
		Err error
	}
	// HelpNoChainRPCRes is the result from a call to HelpNoChainRPC
	HelpNoChainRPCRes struct {
		Res *string
		Err error
	}
	// ImportPrivKeyRes is the result from a call to ImportPrivKey
	ImportPrivKeyRes struct {
		Res *None
		Err error
	}
	// KeypoolRefillRes is the result from a call to KeypoolRefill
	KeypoolRefillRes struct {
		Res *None
		Err error
	}
	// ListAccountsRes is the result from a call to ListAccounts
	ListAccountsRes struct {
		Res *map[string]float64
		Err error
	}
	// ListAddressTransactionsRes is the result from a call to ListAddressTransactions
	ListAddressTransactionsRes struct {
		Res *[]btcjson.ListTransactionsResult
		Err error
	}
	// ListAllTransactionsRes is the result from a call to ListAllTransactions
	ListAllTransactionsRes struct {
		Res *[]btcjson.ListTransactionsResult
		Err error
	}
	// ListLockUnspentRes is the result from a call to ListLockUnspent
	ListLockUnspentRes struct {
		Res *[]btcjson.TransactionInput
		Err error
	}
	// ListReceivedByAccountRes is the result from a call to ListReceivedByAccount
	ListReceivedByAccountRes struct {
		Res *[]btcjson.ListReceivedByAccountResult
		Err error
	}
	// ListReceivedByAddressRes is the result from a call to ListReceivedByAddress
	ListReceivedByAddressRes struct {
		Res *btcjson.ListReceivedByAddressResult
		Err error
	}
	// ListSinceBlockRes is the result from a call to ListSinceBlock
	ListSinceBlockRes struct {
		Res *btcjson.ListSinceBlockResult
		Err error
	}
	// ListTransactionsRes is the result from a call to ListTransactions
	ListTransactionsRes struct {
		Res *[]btcjson.ListTransactionsResult
		Err error
	}
	// ListUnspentRes is the result from a call to ListUnspent
	ListUnspentRes struct {
		Res *[]btcjson.ListUnspentResult
		Err error
	}
	// RenameAccountRes is the result from a call to RenameAccount
	RenameAccountRes struct {
		Res *None
		Err error
	}
	// LockUnspentRes is the result from a call to LockUnspent
	LockUnspentRes struct {
		Res *bool
		Err error
	}
	// SendManyRes is the result from a call to SendMany
	SendManyRes struct {
		Res *string
		Err error
	}
	// SendToAddressRes is the result from a call to SendToAddress
	SendToAddressRes struct {
		Res *string
		Err error
	}
	// SetTxFeeRes is the result from a call to SetTxFee
	SetTxFeeRes struct {
		Res *bool
		Err error
	}
	// SignMessageRes is the result from a call to SignMessage
	SignMessageRes struct {
		Res *string
		Err error
	}
	// SignRawTransactionRes is the result from a call to SignRawTransaction
	SignRawTransactionRes struct {
		Res *btcjson.SignRawTransactionResult
		Err error
	}
	// ValidateAddressRes is the result from a call to ValidateAddress
	ValidateAddressRes struct {
		Res *btcjson.ValidateAddressWalletResult
		Err error
	}
	// VerifyMessageRes is the result from a call to VerifyMessage
	VerifyMessageRes struct {
		Res *bool
		Err error
	}
	// WalletIsLockedRes is the result from a call to WalletIsLocked
	WalletIsLockedRes struct {
		Res *bool
		Err error
	}
	// WalletLockRes is the result from a call to WalletLock
	WalletLockRes struct {
		Res *None
		Err error
	}
	// WalletPassphraseRes is the result from a call to WalletPassphrase
	WalletPassphraseRes struct {
		Res *None
		Err error
	}
	// WalletPassphraseChangeRes is the result from a call to WalletPassphraseChange
	WalletPassphraseChangeRes struct {
		Res *None
		Err error
	}
)

// RequestHandler is a handler function to handle an unmarshaled and parsed request into a marshalable response.  If the 
// error is a *json.RPCError or any of the above special error classes, the server will respond with the JSON-RPC 
// appropriate error code.  All other errors use the wallet catch-all error code, json.ErrRPCWallet.
type RequestHandler func(interface{}, *wallet.Wallet,
...*chain.RPCClient) (interface{}, error)

// RPCHandlers is all of the RPC calls available
//
// - Handler is the handler function
// 
// - Call is a channel carrying a struct containing parameters and error that is listened to in RunAPI to dispatch the 
//   calls
// 
// - Result is a bundle of command parameters and a channel that the result will be sent back on
//
// Get and save the Result function's return, and you can then call the call functions check, result and wait functions 
// for asynchronous and synchronous calls to RPC functions
var RPCHandlers = map[string]struct {
	Handler RequestHandler
	// Function variables cannot be compared against anything but nil, so use a boolean to record whether help 
	// generation is necessary.  This is used by the tests to ensure that help can be generated for every implemented
	// method.
	//
	// A single map and this bool is here is used rather than several maps for the unimplemented handlers so every 
	// method has exactly one handler function.
	//
	// The Return field returns a new channel of the type returned by this function. This makes it possible to use this 
	// for callers to receive a response in the cpc library which implements the functions as channel pipes
	NoHelp bool
	Call   chan API
	Params interface{}
	Result func() API
}{
	"addmultisigaddress": {
		Handler: AddMultiSigAddress, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan AddMultiSigAddressRes)} }},
	"createmultisig": {
		Handler: CreateMultiSig, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan CreateMultiSigRes)} }},
	"createnewaccount": {
		Handler: CreateNewAccount, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan CreateNewAccountRes)} }},
	"dropwallethistory": {
		Handler: HandleDropWalletHistory, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan HandleDropWalletHistoryRes)} }},
	"dumpprivkey": {
		Handler: DumpPrivKey, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan DumpPrivKeyRes)} }},
	"getaccount": {
		Handler: GetAccount, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan GetAccountRes)} }},
	"getaccountaddress": {
		Handler: GetAccountAddress, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan GetAccountAddressRes)} }},
	"getaddressesbyaccount": {
		Handler: GetAddressesByAccount, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan GetAddressesByAccountRes)} }},
	"getbalance": {
		Handler: GetBalance, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan GetBalanceRes)} }},
	"getbestblock": {
		Handler: GetBestBlock, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan GetBestBlockRes)} }},
	"getbestblockhash": {
		Handler: GetBestBlockHash, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan GetBestBlockHashRes)} }},
	"getblockcount": {
		Handler: GetBlockCount, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan GetBlockCountRes)} }},
	"getinfo": {
		Handler: GetInfo, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan GetInfoRes)} }},
	"getnewaddress": {
		Handler: GetNewAddress, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan GetNewAddressRes)} }},
	"getrawchangeaddress": {
		Handler: GetRawChangeAddress, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan GetRawChangeAddressRes)} }},
	"getreceivedbyaccount": {
		Handler: GetReceivedByAccount, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan GetReceivedByAccountRes)} }},
	"getreceivedbyaddress": {
		Handler: GetReceivedByAddress, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan GetReceivedByAddressRes)} }},
	"gettransaction": {
		Handler: GetTransaction, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan GetTransactionRes)} }},
	"getunconfirmedbalance": {
		Handler: GetUnconfirmedBalance, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan GetUnconfirmedBalanceRes)} }},
	"help": {
		Handler: HelpNoChainRPC, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan HelpNoChainRPCRes)} }},
	"importprivkey": {
		Handler: ImportPrivKey, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan ImportPrivKeyRes)} }},
	"keypoolrefill": {
		Handler: KeypoolRefill, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan KeypoolRefillRes)} }},
	"listaccounts": {
		Handler: ListAccounts, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan ListAccountsRes)} }},
	"listaddresstransactions": {
		Handler: ListAddressTransactions, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan ListAddressTransactionsRes)} }},
	"listalltransactions": {
		Handler: ListAllTransactions, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan ListAllTransactionsRes)} }},
	"listlockunspent": {
		Handler: ListLockUnspent, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan ListLockUnspentRes)} }},
	"listreceivedbyaccount": {
		Handler: ListReceivedByAccount, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan ListReceivedByAccountRes)} }},
	"listreceivedbyaddress": {
		Handler: ListReceivedByAddress, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan ListReceivedByAddressRes)} }},
	"listsinceblock": {
		Handler: ListSinceBlock, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan ListSinceBlockRes)} }},
	"listtransactions": {
		Handler: ListTransactions, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan ListTransactionsRes)} }},
	"listunspent": {
		Handler: ListUnspent, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan ListUnspentRes)} }},
	"renameaccount": {
		Handler: RenameAccount, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan RenameAccountRes)} }},
	"sendfrom": {
		Handler: LockUnspent, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan LockUnspentRes)} }},
	"sendmany": {
		Handler: SendMany, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan SendManyRes)} }},
	"sendtoaddress": {
		Handler: SendToAddress, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan SendToAddressRes)} }},
	"settxfee": {
		Handler: SetTxFee, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan SetTxFeeRes)} }},
	"signmessage": {
		Handler: SignMessage, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan SignMessageRes)} }},
	"signrawtransaction": {
		Handler: SignRawTransaction, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan SignRawTransactionRes)} }},
	"validateaddress": {
		Handler: ValidateAddress, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan ValidateAddressRes)} }},
	"verifymessage": {
		Handler: VerifyMessage, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan VerifyMessageRes)} }},
	"walletislocked": {
		Handler: WalletIsLocked, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan WalletIsLockedRes)} }},
	"walletlock": {
		Handler: WalletLock, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan WalletLockRes)} }},
	"walletpassphrase": {
		Handler: WalletPassphrase, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan WalletPassphraseRes)} }},
	"walletpassphrasechange": {
		Handler: WalletPassphraseChange, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan WalletPassphraseChangeRes)} }},
}

// API functions
//
// The functions here provide access to the RPC through a convenient set of functions generated for each call in the RPC 
// API to request, check for, access the results and wait on results

// AddMultiSigAddress calls the method with the given parameters
func (a API) AddMultiSigAddress(cmd *btcjson.AddMultisigAddressCmd) (err error) {
	RPCHandlers["addmultisigaddress"].Call <- API{a.Ch, cmd, nil}
	return
}

// AddMultiSigAddressCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) AddMultiSigAddressCheck() (isNew bool) {
	select {
	case o := <-a.Ch.(chan AddMultiSigAddressRes):
		if o.Err != nil {
			a.Result = o.Err
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// AddMultiSigAddressGetRes returns a pointer to the value in the Result field
func (a API) AddMultiSigAddressGetRes() (out *string, err error) {
	out, _ = a.Result.(*string)
	err, _ = a.Result.(error)
	return
}

// AddMultiSigAddressWait calls the method and blocks until it returns or 5 seconds passes
func (a API) AddMultiSigAddressWait(cmd *btcjson.AddMultisigAddressCmd) (out *string, err error) {
	RPCHandlers["addmultisigaddress"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second * 5):
		break
	case o := <-a.Ch.(chan AddMultiSigAddressRes):
		out, err = o.Res, o.Err
	}
	return
}

// CreateMultiSig calls the method with the given parameters
func (a API) CreateMultiSig(cmd *btcjson.CreateMultisigCmd) (err error) {
	RPCHandlers["createmultisig"].Call <- API{a.Ch, cmd, nil}
	return
}

// CreateMultiSigCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) CreateMultiSigCheck() (isNew bool) {
	select {
	case o := <-a.Ch.(chan CreateMultiSigRes):
		if o.Err != nil {
			a.Result = o.Err
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// CreateMultiSigGetRes returns a pointer to the value in the Result field
func (a API) CreateMultiSigGetRes() (out *btcjson.CreateMultiSigResult, err error) {
	out, _ = a.Result.(*btcjson.CreateMultiSigResult)
	err, _ = a.Result.(error)
	return
}

// CreateMultiSigWait calls the method and blocks until it returns or 5 seconds passes
func (a API) CreateMultiSigWait(cmd *btcjson.CreateMultisigCmd) (out *btcjson.CreateMultiSigResult, err error) {
	RPCHandlers["createmultisig"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second * 5):
		break
	case o := <-a.Ch.(chan CreateMultiSigRes):
		out, err = o.Res, o.Err
	}
	return
}

// CreateNewAccount calls the method with the given parameters
func (a API) CreateNewAccount(cmd *btcjson.CreateNewAccountCmd) (err error) {
	RPCHandlers["createnewaccount"].Call <- API{a.Ch, cmd, nil}
	return
}

// CreateNewAccountCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) CreateNewAccountCheck() (isNew bool) {
	select {
	case o := <-a.Ch.(chan CreateNewAccountRes):
		if o.Err != nil {
			a.Result = o.Err
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// CreateNewAccountGetRes returns a pointer to the value in the Result field
func (a API) CreateNewAccountGetRes() (out *None, err error) {
	out, _ = a.Result.(*None)
	err, _ = a.Result.(error)
	return
}

// CreateNewAccountWait calls the method and blocks until it returns or 5 seconds passes
func (a API) CreateNewAccountWait(cmd *btcjson.CreateNewAccountCmd) (out *None, err error) {
	RPCHandlers["createnewaccount"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second * 5):
		break
	case o := <-a.Ch.(chan CreateNewAccountRes):
		out, err = o.Res, o.Err
	}
	return
}

// HandleDropWalletHistory calls the method with the given parameters
func (a API) HandleDropWalletHistory(cmd *None) (err error) {
	RPCHandlers["dropwallethistory"].Call <- API{a.Ch, cmd, nil}
	return
}

// HandleDropWalletHistoryCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) HandleDropWalletHistoryCheck() (isNew bool) {
	select {
	case o := <-a.Ch.(chan HandleDropWalletHistoryRes):
		if o.Err != nil {
			a.Result = o.Err
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// HandleDropWalletHistoryGetRes returns a pointer to the value in the Result field
func (a API) HandleDropWalletHistoryGetRes() (out *string, err error) {
	out, _ = a.Result.(*string)
	err, _ = a.Result.(error)
	return
}

// HandleDropWalletHistoryWait calls the method and blocks until it returns or 5 seconds passes
func (a API) HandleDropWalletHistoryWait(cmd *None) (out *string, err error) {
	RPCHandlers["dropwallethistory"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second * 5):
		break
	case o := <-a.Ch.(chan HandleDropWalletHistoryRes):
		out, err = o.Res, o.Err
	}
	return
}

// DumpPrivKey calls the method with the given parameters
func (a API) DumpPrivKey(cmd *btcjson.DumpPrivKeyCmd) (err error) {
	RPCHandlers["dumpprivkey"].Call <- API{a.Ch, cmd, nil}
	return
}

// DumpPrivKeyCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) DumpPrivKeyCheck() (isNew bool) {
	select {
	case o := <-a.Ch.(chan DumpPrivKeyRes):
		if o.Err != nil {
			a.Result = o.Err
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// DumpPrivKeyGetRes returns a pointer to the value in the Result field
func (a API) DumpPrivKeyGetRes() (out *string, err error) {
	out, _ = a.Result.(*string)
	err, _ = a.Result.(error)
	return
}

// DumpPrivKeyWait calls the method and blocks until it returns or 5 seconds passes
func (a API) DumpPrivKeyWait(cmd *btcjson.DumpPrivKeyCmd) (out *string, err error) {
	RPCHandlers["dumpprivkey"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second * 5):
		break
	case o := <-a.Ch.(chan DumpPrivKeyRes):
		out, err = o.Res, o.Err
	}
	return
}

// GetAccount calls the method with the given parameters
func (a API) GetAccount(cmd *btcjson.GetAccountCmd) (err error) {
	RPCHandlers["getaccount"].Call <- API{a.Ch, cmd, nil}
	return
}

// GetAccountCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) GetAccountCheck() (isNew bool) {
	select {
	case o := <-a.Ch.(chan GetAccountRes):
		if o.Err != nil {
			a.Result = o.Err
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// GetAccountGetRes returns a pointer to the value in the Result field
func (a API) GetAccountGetRes() (out *string, err error) {
	out, _ = a.Result.(*string)
	err, _ = a.Result.(error)
	return
}

// GetAccountWait calls the method and blocks until it returns or 5 seconds passes
func (a API) GetAccountWait(cmd *btcjson.GetAccountCmd) (out *string, err error) {
	RPCHandlers["getaccount"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second * 5):
		break
	case o := <-a.Ch.(chan GetAccountRes):
		out, err = o.Res, o.Err
	}
	return
}

// GetAccountAddress calls the method with the given parameters
func (a API) GetAccountAddress(cmd *btcjson.GetAccountAddressCmd) (err error) {
	RPCHandlers["getaccountaddress"].Call <- API{a.Ch, cmd, nil}
	return
}

// GetAccountAddressCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) GetAccountAddressCheck() (isNew bool) {
	select {
	case o := <-a.Ch.(chan GetAccountAddressRes):
		if o.Err != nil {
			a.Result = o.Err
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// GetAccountAddressGetRes returns a pointer to the value in the Result field
func (a API) GetAccountAddressGetRes() (out *string, err error) {
	out, _ = a.Result.(*string)
	err, _ = a.Result.(error)
	return
}

// GetAccountAddressWait calls the method and blocks until it returns or 5 seconds passes
func (a API) GetAccountAddressWait(cmd *btcjson.GetAccountAddressCmd) (out *string, err error) {
	RPCHandlers["getaccountaddress"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second * 5):
		break
	case o := <-a.Ch.(chan GetAccountAddressRes):
		out, err = o.Res, o.Err
	}
	return
}

// GetAddressesByAccount calls the method with the given parameters
func (a API) GetAddressesByAccount(cmd *btcjson.GetAddressesByAccountCmd) (err error) {
	RPCHandlers["getaddressesbyaccount"].Call <- API{a.Ch, cmd, nil}
	return
}

// GetAddressesByAccountCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) GetAddressesByAccountCheck() (isNew bool) {
	select {
	case o := <-a.Ch.(chan GetAddressesByAccountRes):
		if o.Err != nil {
			a.Result = o.Err
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// GetAddressesByAccountGetRes returns a pointer to the value in the Result field
func (a API) GetAddressesByAccountGetRes() (out *[]string, err error) {
	out, _ = a.Result.(*[]string)
	err, _ = a.Result.(error)
	return
}

// GetAddressesByAccountWait calls the method and blocks until it returns or 5 seconds passes
func (a API) GetAddressesByAccountWait(cmd *btcjson.GetAddressesByAccountCmd) (out *[]string, err error) {
	RPCHandlers["getaddressesbyaccount"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second * 5):
		break
	case o := <-a.Ch.(chan GetAddressesByAccountRes):
		out, err = o.Res, o.Err
	}
	return
}

// GetBalance calls the method with the given parameters
func (a API) GetBalance(cmd *btcjson.GetBalanceCmd) (err error) {
	RPCHandlers["getbalance"].Call <- API{a.Ch, cmd, nil}
	return
}

// GetBalanceCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) GetBalanceCheck() (isNew bool) {
	select {
	case o := <-a.Ch.(chan GetBalanceRes):
		if o.Err != nil {
			a.Result = o.Err
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// GetBalanceGetRes returns a pointer to the value in the Result field
func (a API) GetBalanceGetRes() (out *float64, err error) {
	out, _ = a.Result.(*float64)
	err, _ = a.Result.(error)
	return
}

// GetBalanceWait calls the method and blocks until it returns or 5 seconds passes
func (a API) GetBalanceWait(cmd *btcjson.GetBalanceCmd) (out *float64, err error) {
	RPCHandlers["getbalance"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second * 5):
		break
	case o := <-a.Ch.(chan GetBalanceRes):
		out, err = o.Res, o.Err
	}
	return
}

// GetBestBlock calls the method with the given parameters
func (a API) GetBestBlock(cmd *None) (err error) {
	RPCHandlers["getbestblock"].Call <- API{a.Ch, cmd, nil}
	return
}

// GetBestBlockCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) GetBestBlockCheck() (isNew bool) {
	select {
	case o := <-a.Ch.(chan GetBestBlockRes):
		if o.Err != nil {
			a.Result = o.Err
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// GetBestBlockGetRes returns a pointer to the value in the Result field
func (a API) GetBestBlockGetRes() (out *btcjson.GetBestBlockResult, err error) {
	out, _ = a.Result.(*btcjson.GetBestBlockResult)
	err, _ = a.Result.(error)
	return
}

// GetBestBlockWait calls the method and blocks until it returns or 5 seconds passes
func (a API) GetBestBlockWait(cmd *None) (out *btcjson.GetBestBlockResult, err error) {
	RPCHandlers["getbestblock"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second * 5):
		break
	case o := <-a.Ch.(chan GetBestBlockRes):
		out, err = o.Res, o.Err
	}
	return
}

// GetBestBlockHash calls the method with the given parameters
func (a API) GetBestBlockHash(cmd *None) (err error) {
	RPCHandlers["getbestblockhash"].Call <- API{a.Ch, cmd, nil}
	return
}

// GetBestBlockHashCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) GetBestBlockHashCheck() (isNew bool) {
	select {
	case o := <-a.Ch.(chan GetBestBlockHashRes):
		if o.Err != nil {
			a.Result = o.Err
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// GetBestBlockHashGetRes returns a pointer to the value in the Result field
func (a API) GetBestBlockHashGetRes() (out *string, err error) {
	out, _ = a.Result.(*string)
	err, _ = a.Result.(error)
	return
}

// GetBestBlockHashWait calls the method and blocks until it returns or 5 seconds passes
func (a API) GetBestBlockHashWait(cmd *None) (out *string, err error) {
	RPCHandlers["getbestblockhash"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second * 5):
		break
	case o := <-a.Ch.(chan GetBestBlockHashRes):
		out, err = o.Res, o.Err
	}
	return
}

// GetBlockCount calls the method with the given parameters
func (a API) GetBlockCount(cmd *None) (err error) {
	RPCHandlers["getblockcount"].Call <- API{a.Ch, cmd, nil}
	return
}

// GetBlockCountCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) GetBlockCountCheck() (isNew bool) {
	select {
	case o := <-a.Ch.(chan GetBlockCountRes):
		if o.Err != nil {
			a.Result = o.Err
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// GetBlockCountGetRes returns a pointer to the value in the Result field
func (a API) GetBlockCountGetRes() (out *int32, err error) {
	out, _ = a.Result.(*int32)
	err, _ = a.Result.(error)
	return
}

// GetBlockCountWait calls the method and blocks until it returns or 5 seconds passes
func (a API) GetBlockCountWait(cmd *None) (out *int32, err error) {
	RPCHandlers["getblockcount"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second * 5):
		break
	case o := <-a.Ch.(chan GetBlockCountRes):
		out, err = o.Res, o.Err
	}
	return
}

// GetInfo calls the method with the given parameters
func (a API) GetInfo(cmd *None) (err error) {
	RPCHandlers["getinfo"].Call <- API{a.Ch, cmd, nil}
	return
}

// GetInfoCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) GetInfoCheck() (isNew bool) {
	select {
	case o := <-a.Ch.(chan GetInfoRes):
		if o.Err != nil {
			a.Result = o.Err
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// GetInfoGetRes returns a pointer to the value in the Result field
func (a API) GetInfoGetRes() (out *btcjson.InfoWalletResult, err error) {
	out, _ = a.Result.(*btcjson.InfoWalletResult)
	err, _ = a.Result.(error)
	return
}

// GetInfoWait calls the method and blocks until it returns or 5 seconds passes
func (a API) GetInfoWait(cmd *None) (out *btcjson.InfoWalletResult, err error) {
	RPCHandlers["getinfo"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second * 5):
		break
	case o := <-a.Ch.(chan GetInfoRes):
		out, err = o.Res, o.Err
	}
	return
}

// GetNewAddress calls the method with the given parameters
func (a API) GetNewAddress(cmd *btcjson.GetNewAddressCmd) (err error) {
	RPCHandlers["getnewaddress"].Call <- API{a.Ch, cmd, nil}
	return
}

// GetNewAddressCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) GetNewAddressCheck() (isNew bool) {
	select {
	case o := <-a.Ch.(chan GetNewAddressRes):
		if o.Err != nil {
			a.Result = o.Err
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// GetNewAddressGetRes returns a pointer to the value in the Result field
func (a API) GetNewAddressGetRes() (out *string, err error) {
	out, _ = a.Result.(*string)
	err, _ = a.Result.(error)
	return
}

// GetNewAddressWait calls the method and blocks until it returns or 5 seconds passes
func (a API) GetNewAddressWait(cmd *btcjson.GetNewAddressCmd) (out *string, err error) {
	RPCHandlers["getnewaddress"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second * 5):
		break
	case o := <-a.Ch.(chan GetNewAddressRes):
		out, err = o.Res, o.Err
	}
	return
}

// GetRawChangeAddress calls the method with the given parameters
func (a API) GetRawChangeAddress(cmd *btcjson.GetRawChangeAddressCmd) (err error) {
	RPCHandlers["getrawchangeaddress"].Call <- API{a.Ch, cmd, nil}
	return
}

// GetRawChangeAddressCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) GetRawChangeAddressCheck() (isNew bool) {
	select {
	case o := <-a.Ch.(chan GetRawChangeAddressRes):
		if o.Err != nil {
			a.Result = o.Err
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// GetRawChangeAddressGetRes returns a pointer to the value in the Result field
func (a API) GetRawChangeAddressGetRes() (out *string, err error) {
	out, _ = a.Result.(*string)
	err, _ = a.Result.(error)
	return
}

// GetRawChangeAddressWait calls the method and blocks until it returns or 5 seconds passes
func (a API) GetRawChangeAddressWait(cmd *btcjson.GetRawChangeAddressCmd) (out *string, err error) {
	RPCHandlers["getrawchangeaddress"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second * 5):
		break
	case o := <-a.Ch.(chan GetRawChangeAddressRes):
		out, err = o.Res, o.Err
	}
	return
}

// GetReceivedByAccount calls the method with the given parameters
func (a API) GetReceivedByAccount(cmd *btcjson.GetReceivedByAccountCmd) (err error) {
	RPCHandlers["getreceivedbyaccount"].Call <- API{a.Ch, cmd, nil}
	return
}

// GetReceivedByAccountCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) GetReceivedByAccountCheck() (isNew bool) {
	select {
	case o := <-a.Ch.(chan GetReceivedByAccountRes):
		if o.Err != nil {
			a.Result = o.Err
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// GetReceivedByAccountGetRes returns a pointer to the value in the Result field
func (a API) GetReceivedByAccountGetRes() (out *float64, err error) {
	out, _ = a.Result.(*float64)
	err, _ = a.Result.(error)
	return
}

// GetReceivedByAccountWait calls the method and blocks until it returns or 5 seconds passes
func (a API) GetReceivedByAccountWait(cmd *btcjson.GetReceivedByAccountCmd) (out *float64, err error) {
	RPCHandlers["getreceivedbyaccount"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second * 5):
		break
	case o := <-a.Ch.(chan GetReceivedByAccountRes):
		out, err = o.Res, o.Err
	}
	return
}

// GetReceivedByAddress calls the method with the given parameters
func (a API) GetReceivedByAddress(cmd *btcjson.GetReceivedByAddressCmd) (err error) {
	RPCHandlers["getreceivedbyaddress"].Call <- API{a.Ch, cmd, nil}
	return
}

// GetReceivedByAddressCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) GetReceivedByAddressCheck() (isNew bool) {
	select {
	case o := <-a.Ch.(chan GetReceivedByAddressRes):
		if o.Err != nil {
			a.Result = o.Err
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// GetReceivedByAddressGetRes returns a pointer to the value in the Result field
func (a API) GetReceivedByAddressGetRes() (out *float64, err error) {
	out, _ = a.Result.(*float64)
	err, _ = a.Result.(error)
	return
}

// GetReceivedByAddressWait calls the method and blocks until it returns or 5 seconds passes
func (a API) GetReceivedByAddressWait(cmd *btcjson.GetReceivedByAddressCmd) (out *float64, err error) {
	RPCHandlers["getreceivedbyaddress"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second * 5):
		break
	case o := <-a.Ch.(chan GetReceivedByAddressRes):
		out, err = o.Res, o.Err
	}
	return
}

// GetTransaction calls the method with the given parameters
func (a API) GetTransaction(cmd *btcjson.GetTransactionCmd) (err error) {
	RPCHandlers["gettransaction"].Call <- API{a.Ch, cmd, nil}
	return
}

// GetTransactionCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) GetTransactionCheck() (isNew bool) {
	select {
	case o := <-a.Ch.(chan GetTransactionRes):
		if o.Err != nil {
			a.Result = o.Err
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// GetTransactionGetRes returns a pointer to the value in the Result field
func (a API) GetTransactionGetRes() (out *btcjson.GetTransactionResult, err error) {
	out, _ = a.Result.(*btcjson.GetTransactionResult)
	err, _ = a.Result.(error)
	return
}

// GetTransactionWait calls the method and blocks until it returns or 5 seconds passes
func (a API) GetTransactionWait(cmd *btcjson.GetTransactionCmd) (out *btcjson.GetTransactionResult, err error) {
	RPCHandlers["gettransaction"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second * 5):
		break
	case o := <-a.Ch.(chan GetTransactionRes):
		out, err = o.Res, o.Err
	}
	return
}

// GetUnconfirmedBalance calls the method with the given parameters
func (a API) GetUnconfirmedBalance(cmd *btcjson.GetUnconfirmedBalanceCmd) (err error) {
	RPCHandlers["getunconfirmedbalance"].Call <- API{a.Ch, cmd, nil}
	return
}

// GetUnconfirmedBalanceCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) GetUnconfirmedBalanceCheck() (isNew bool) {
	select {
	case o := <-a.Ch.(chan GetUnconfirmedBalanceRes):
		if o.Err != nil {
			a.Result = o.Err
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// GetUnconfirmedBalanceGetRes returns a pointer to the value in the Result field
func (a API) GetUnconfirmedBalanceGetRes() (out *float64, err error) {
	out, _ = a.Result.(*float64)
	err, _ = a.Result.(error)
	return
}

// GetUnconfirmedBalanceWait calls the method and blocks until it returns or 5 seconds passes
func (a API) GetUnconfirmedBalanceWait(cmd *btcjson.GetUnconfirmedBalanceCmd) (out *float64, err error) {
	RPCHandlers["getunconfirmedbalance"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second * 5):
		break
	case o := <-a.Ch.(chan GetUnconfirmedBalanceRes):
		out, err = o.Res, o.Err
	}
	return
}

// HelpNoChainRPC calls the method with the given parameters
func (a API) HelpNoChainRPC(cmd btcjson.HelpCmd) (err error) {
	RPCHandlers["help"].Call <- API{a.Ch, cmd, nil}
	return
}

// HelpNoChainRPCCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) HelpNoChainRPCCheck() (isNew bool) {
	select {
	case o := <-a.Ch.(chan HelpNoChainRPCRes):
		if o.Err != nil {
			a.Result = o.Err
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// HelpNoChainRPCGetRes returns a pointer to the value in the Result field
func (a API) HelpNoChainRPCGetRes() (out *string, err error) {
	out, _ = a.Result.(*string)
	err, _ = a.Result.(error)
	return
}

// HelpNoChainRPCWait calls the method and blocks until it returns or 5 seconds passes
func (a API) HelpNoChainRPCWait(cmd btcjson.HelpCmd) (out *string, err error) {
	RPCHandlers["help"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second * 5):
		break
	case o := <-a.Ch.(chan HelpNoChainRPCRes):
		out, err = o.Res, o.Err
	}
	return
}

// ImportPrivKey calls the method with the given parameters
func (a API) ImportPrivKey(cmd *btcjson.ImportPrivKeyCmd) (err error) {
	RPCHandlers["importprivkey"].Call <- API{a.Ch, cmd, nil}
	return
}

// ImportPrivKeyCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) ImportPrivKeyCheck() (isNew bool) {
	select {
	case o := <-a.Ch.(chan ImportPrivKeyRes):
		if o.Err != nil {
			a.Result = o.Err
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// ImportPrivKeyGetRes returns a pointer to the value in the Result field
func (a API) ImportPrivKeyGetRes() (out *None, err error) {
	out, _ = a.Result.(*None)
	err, _ = a.Result.(error)
	return
}

// ImportPrivKeyWait calls the method and blocks until it returns or 5 seconds passes
func (a API) ImportPrivKeyWait(cmd *btcjson.ImportPrivKeyCmd) (out *None, err error) {
	RPCHandlers["importprivkey"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second * 5):
		break
	case o := <-a.Ch.(chan ImportPrivKeyRes):
		out, err = o.Res, o.Err
	}
	return
}

// KeypoolRefill calls the method with the given parameters
func (a API) KeypoolRefill(cmd *None) (err error) {
	RPCHandlers["keypoolrefill"].Call <- API{a.Ch, cmd, nil}
	return
}

// KeypoolRefillCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) KeypoolRefillCheck() (isNew bool) {
	select {
	case o := <-a.Ch.(chan KeypoolRefillRes):
		if o.Err != nil {
			a.Result = o.Err
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// KeypoolRefillGetRes returns a pointer to the value in the Result field
func (a API) KeypoolRefillGetRes() (out *None, err error) {
	out, _ = a.Result.(*None)
	err, _ = a.Result.(error)
	return
}

// KeypoolRefillWait calls the method and blocks until it returns or 5 seconds passes
func (a API) KeypoolRefillWait(cmd *None) (out *None, err error) {
	RPCHandlers["keypoolrefill"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second * 5):
		break
	case o := <-a.Ch.(chan KeypoolRefillRes):
		out, err = o.Res, o.Err
	}
	return
}

// ListAccounts calls the method with the given parameters
func (a API) ListAccounts(cmd *btcjson.ListAccountsCmd) (err error) {
	RPCHandlers["listaccounts"].Call <- API{a.Ch, cmd, nil}
	return
}

// ListAccountsCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) ListAccountsCheck() (isNew bool) {
	select {
	case o := <-a.Ch.(chan ListAccountsRes):
		if o.Err != nil {
			a.Result = o.Err
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// ListAccountsGetRes returns a pointer to the value in the Result field
func (a API) ListAccountsGetRes() (out *map[string]float64, err error) {
	out, _ = a.Result.(*map[string]float64)
	err, _ = a.Result.(error)
	return
}

// ListAccountsWait calls the method and blocks until it returns or 5 seconds passes
func (a API) ListAccountsWait(cmd *btcjson.ListAccountsCmd) (out *map[string]float64, err error) {
	RPCHandlers["listaccounts"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second * 5):
		break
	case o := <-a.Ch.(chan ListAccountsRes):
		out, err = o.Res, o.Err
	}
	return
}

// ListAddressTransactions calls the method with the given parameters
func (a API) ListAddressTransactions(cmd *btcjson.ListAddressTransactionsCmd) (err error) {
	RPCHandlers["listaddresstransactions"].Call <- API{a.Ch, cmd, nil}
	return
}

// ListAddressTransactionsCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) ListAddressTransactionsCheck() (isNew bool) {
	select {
	case o := <-a.Ch.(chan ListAddressTransactionsRes):
		if o.Err != nil {
			a.Result = o.Err
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// ListAddressTransactionsGetRes returns a pointer to the value in the Result field
func (a API) ListAddressTransactionsGetRes() (out *[]btcjson.ListTransactionsResult, err error) {
	out, _ = a.Result.(*[]btcjson.ListTransactionsResult)
	err, _ = a.Result.(error)
	return
}

// ListAddressTransactionsWait calls the method and blocks until it returns or 5 seconds passes
func (a API) ListAddressTransactionsWait(cmd *btcjson.ListAddressTransactionsCmd) (out *[]btcjson.ListTransactionsResult, err error) {
	RPCHandlers["listaddresstransactions"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second * 5):
		break
	case o := <-a.Ch.(chan ListAddressTransactionsRes):
		out, err = o.Res, o.Err
	}
	return
}

// ListAllTransactions calls the method with the given parameters
func (a API) ListAllTransactions(cmd *btcjson.ListAllTransactionsCmd) (err error) {
	RPCHandlers["listalltransactions"].Call <- API{a.Ch, cmd, nil}
	return
}

// ListAllTransactionsCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) ListAllTransactionsCheck() (isNew bool) {
	select {
	case o := <-a.Ch.(chan ListAllTransactionsRes):
		if o.Err != nil {
			a.Result = o.Err
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// ListAllTransactionsGetRes returns a pointer to the value in the Result field
func (a API) ListAllTransactionsGetRes() (out *[]btcjson.ListTransactionsResult, err error) {
	out, _ = a.Result.(*[]btcjson.ListTransactionsResult)
	err, _ = a.Result.(error)
	return
}

// ListAllTransactionsWait calls the method and blocks until it returns or 5 seconds passes
func (a API) ListAllTransactionsWait(cmd *btcjson.ListAllTransactionsCmd) (out *[]btcjson.ListTransactionsResult, err error) {
	RPCHandlers["listalltransactions"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second * 5):
		break
	case o := <-a.Ch.(chan ListAllTransactionsRes):
		out, err = o.Res, o.Err
	}
	return
}

// ListLockUnspent calls the method with the given parameters
func (a API) ListLockUnspent(cmd *None) (err error) {
	RPCHandlers["listlockunspent"].Call <- API{a.Ch, cmd, nil}
	return
}

// ListLockUnspentCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) ListLockUnspentCheck() (isNew bool) {
	select {
	case o := <-a.Ch.(chan ListLockUnspentRes):
		if o.Err != nil {
			a.Result = o.Err
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// ListLockUnspentGetRes returns a pointer to the value in the Result field
func (a API) ListLockUnspentGetRes() (out *[]btcjson.TransactionInput, err error) {
	out, _ = a.Result.(*[]btcjson.TransactionInput)
	err, _ = a.Result.(error)
	return
}

// ListLockUnspentWait calls the method and blocks until it returns or 5 seconds passes
func (a API) ListLockUnspentWait(cmd *None) (out *[]btcjson.TransactionInput, err error) {
	RPCHandlers["listlockunspent"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second * 5):
		break
	case o := <-a.Ch.(chan ListLockUnspentRes):
		out, err = o.Res, o.Err
	}
	return
}

// ListReceivedByAccount calls the method with the given parameters
func (a API) ListReceivedByAccount(cmd *btcjson.ListReceivedByAccountCmd) (err error) {
	RPCHandlers["listreceivedbyaccount"].Call <- API{a.Ch, cmd, nil}
	return
}

// ListReceivedByAccountCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) ListReceivedByAccountCheck() (isNew bool) {
	select {
	case o := <-a.Ch.(chan ListReceivedByAccountRes):
		if o.Err != nil {
			a.Result = o.Err
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// ListReceivedByAccountGetRes returns a pointer to the value in the Result field
func (a API) ListReceivedByAccountGetRes() (out *[]btcjson.ListReceivedByAccountResult, err error) {
	out, _ = a.Result.(*[]btcjson.ListReceivedByAccountResult)
	err, _ = a.Result.(error)
	return
}

// ListReceivedByAccountWait calls the method and blocks until it returns or 5 seconds passes
func (a API) ListReceivedByAccountWait(cmd *btcjson.ListReceivedByAccountCmd) (out *[]btcjson.ListReceivedByAccountResult, err error) {
	RPCHandlers["listreceivedbyaccount"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second * 5):
		break
	case o := <-a.Ch.(chan ListReceivedByAccountRes):
		out, err = o.Res, o.Err
	}
	return
}

// ListReceivedByAddress calls the method with the given parameters
func (a API) ListReceivedByAddress(cmd *btcjson.ListReceivedByAddressCmd) (err error) {
	RPCHandlers["listreceivedbyaddress"].Call <- API{a.Ch, cmd, nil}
	return
}

// ListReceivedByAddressCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) ListReceivedByAddressCheck() (isNew bool) {
	select {
	case o := <-a.Ch.(chan ListReceivedByAddressRes):
		if o.Err != nil {
			a.Result = o.Err
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// ListReceivedByAddressGetRes returns a pointer to the value in the Result field
func (a API) ListReceivedByAddressGetRes() (out *btcjson.ListReceivedByAddressResult, err error) {
	out, _ = a.Result.(*btcjson.ListReceivedByAddressResult)
	err, _ = a.Result.(error)
	return
}

// ListReceivedByAddressWait calls the method and blocks until it returns or 5 seconds passes
func (a API) ListReceivedByAddressWait(cmd *btcjson.ListReceivedByAddressCmd) (out *btcjson.ListReceivedByAddressResult, err error) {
	RPCHandlers["listreceivedbyaddress"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second * 5):
		break
	case o := <-a.Ch.(chan ListReceivedByAddressRes):
		out, err = o.Res, o.Err
	}
	return
}

// ListSinceBlock calls the method with the given parameters
func (a API) ListSinceBlock(cmd btcjson.ListSinceBlockCmd) (err error) {
	RPCHandlers["listsinceblock"].Call <- API{a.Ch, cmd, nil}
	return
}

// ListSinceBlockCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) ListSinceBlockCheck() (isNew bool) {
	select {
	case o := <-a.Ch.(chan ListSinceBlockRes):
		if o.Err != nil {
			a.Result = o.Err
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// ListSinceBlockGetRes returns a pointer to the value in the Result field
func (a API) ListSinceBlockGetRes() (out *btcjson.ListSinceBlockResult, err error) {
	out, _ = a.Result.(*btcjson.ListSinceBlockResult)
	err, _ = a.Result.(error)
	return
}

// ListSinceBlockWait calls the method and blocks until it returns or 5 seconds passes
func (a API) ListSinceBlockWait(cmd btcjson.ListSinceBlockCmd) (out *btcjson.ListSinceBlockResult, err error) {
	RPCHandlers["listsinceblock"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second * 5):
		break
	case o := <-a.Ch.(chan ListSinceBlockRes):
		out, err = o.Res, o.Err
	}
	return
}

// ListTransactions calls the method with the given parameters
func (a API) ListTransactions(cmd *btcjson.ListTransactionsCmd) (err error) {
	RPCHandlers["listtransactions"].Call <- API{a.Ch, cmd, nil}
	return
}

// ListTransactionsCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) ListTransactionsCheck() (isNew bool) {
	select {
	case o := <-a.Ch.(chan ListTransactionsRes):
		if o.Err != nil {
			a.Result = o.Err
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// ListTransactionsGetRes returns a pointer to the value in the Result field
func (a API) ListTransactionsGetRes() (out *[]btcjson.ListTransactionsResult, err error) {
	out, _ = a.Result.(*[]btcjson.ListTransactionsResult)
	err, _ = a.Result.(error)
	return
}

// ListTransactionsWait calls the method and blocks until it returns or 5 seconds passes
func (a API) ListTransactionsWait(cmd *btcjson.ListTransactionsCmd) (out *[]btcjson.ListTransactionsResult, err error) {
	RPCHandlers["listtransactions"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second * 5):
		break
	case o := <-a.Ch.(chan ListTransactionsRes):
		out, err = o.Res, o.Err
	}
	return
}

// ListUnspent calls the method with the given parameters
func (a API) ListUnspent(cmd *btcjson.ListUnspentCmd) (err error) {
	RPCHandlers["listunspent"].Call <- API{a.Ch, cmd, nil}
	return
}

// ListUnspentCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) ListUnspentCheck() (isNew bool) {
	select {
	case o := <-a.Ch.(chan ListUnspentRes):
		if o.Err != nil {
			a.Result = o.Err
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// ListUnspentGetRes returns a pointer to the value in the Result field
func (a API) ListUnspentGetRes() (out *[]btcjson.ListUnspentResult, err error) {
	out, _ = a.Result.(*[]btcjson.ListUnspentResult)
	err, _ = a.Result.(error)
	return
}

// ListUnspentWait calls the method and blocks until it returns or 5 seconds passes
func (a API) ListUnspentWait(cmd *btcjson.ListUnspentCmd) (out *[]btcjson.ListUnspentResult, err error) {
	RPCHandlers["listunspent"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second * 5):
		break
	case o := <-a.Ch.(chan ListUnspentRes):
		out, err = o.Res, o.Err
	}
	return
}

// RenameAccount calls the method with the given parameters
func (a API) RenameAccount(cmd *btcjson.RenameAccountCmd) (err error) {
	RPCHandlers["renameaccount"].Call <- API{a.Ch, cmd, nil}
	return
}

// RenameAccountCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) RenameAccountCheck() (isNew bool) {
	select {
	case o := <-a.Ch.(chan RenameAccountRes):
		if o.Err != nil {
			a.Result = o.Err
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// RenameAccountGetRes returns a pointer to the value in the Result field
func (a API) RenameAccountGetRes() (out *None, err error) {
	out, _ = a.Result.(*None)
	err, _ = a.Result.(error)
	return
}

// RenameAccountWait calls the method and blocks until it returns or 5 seconds passes
func (a API) RenameAccountWait(cmd *btcjson.RenameAccountCmd) (out *None, err error) {
	RPCHandlers["renameaccount"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second * 5):
		break
	case o := <-a.Ch.(chan RenameAccountRes):
		out, err = o.Res, o.Err
	}
	return
}

// LockUnspent calls the method with the given parameters
func (a API) LockUnspent(cmd btcjson.LockUnspentCmd) (err error) {
	RPCHandlers["sendfrom"].Call <- API{a.Ch, cmd, nil}
	return
}

// LockUnspentCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) LockUnspentCheck() (isNew bool) {
	select {
	case o := <-a.Ch.(chan LockUnspentRes):
		if o.Err != nil {
			a.Result = o.Err
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// LockUnspentGetRes returns a pointer to the value in the Result field
func (a API) LockUnspentGetRes() (out *bool, err error) {
	out, _ = a.Result.(*bool)
	err, _ = a.Result.(error)
	return
}

// LockUnspentWait calls the method and blocks until it returns or 5 seconds passes
func (a API) LockUnspentWait(cmd btcjson.LockUnspentCmd) (out *bool, err error) {
	RPCHandlers["sendfrom"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second * 5):
		break
	case o := <-a.Ch.(chan LockUnspentRes):
		out, err = o.Res, o.Err
	}
	return
}

// SendMany calls the method with the given parameters
func (a API) SendMany(cmd *btcjson.SendManyCmd) (err error) {
	RPCHandlers["sendmany"].Call <- API{a.Ch, cmd, nil}
	return
}

// SendManyCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) SendManyCheck() (isNew bool) {
	select {
	case o := <-a.Ch.(chan SendManyRes):
		if o.Err != nil {
			a.Result = o.Err
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// SendManyGetRes returns a pointer to the value in the Result field
func (a API) SendManyGetRes() (out *string, err error) {
	out, _ = a.Result.(*string)
	err, _ = a.Result.(error)
	return
}

// SendManyWait calls the method and blocks until it returns or 5 seconds passes
func (a API) SendManyWait(cmd *btcjson.SendManyCmd) (out *string, err error) {
	RPCHandlers["sendmany"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second * 5):
		break
	case o := <-a.Ch.(chan SendManyRes):
		out, err = o.Res, o.Err
	}
	return
}

// SendToAddress calls the method with the given parameters
func (a API) SendToAddress(cmd *btcjson.SendToAddressCmd) (err error) {
	RPCHandlers["sendtoaddress"].Call <- API{a.Ch, cmd, nil}
	return
}

// SendToAddressCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) SendToAddressCheck() (isNew bool) {
	select {
	case o := <-a.Ch.(chan SendToAddressRes):
		if o.Err != nil {
			a.Result = o.Err
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// SendToAddressGetRes returns a pointer to the value in the Result field
func (a API) SendToAddressGetRes() (out *string, err error) {
	out, _ = a.Result.(*string)
	err, _ = a.Result.(error)
	return
}

// SendToAddressWait calls the method and blocks until it returns or 5 seconds passes
func (a API) SendToAddressWait(cmd *btcjson.SendToAddressCmd) (out *string, err error) {
	RPCHandlers["sendtoaddress"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second * 5):
		break
	case o := <-a.Ch.(chan SendToAddressRes):
		out, err = o.Res, o.Err
	}
	return
}

// SetTxFee calls the method with the given parameters
func (a API) SetTxFee(cmd *btcjson.SetTxFeeCmd) (err error) {
	RPCHandlers["settxfee"].Call <- API{a.Ch, cmd, nil}
	return
}

// SetTxFeeCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) SetTxFeeCheck() (isNew bool) {
	select {
	case o := <-a.Ch.(chan SetTxFeeRes):
		if o.Err != nil {
			a.Result = o.Err
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// SetTxFeeGetRes returns a pointer to the value in the Result field
func (a API) SetTxFeeGetRes() (out *bool, err error) {
	out, _ = a.Result.(*bool)
	err, _ = a.Result.(error)
	return
}

// SetTxFeeWait calls the method and blocks until it returns or 5 seconds passes
func (a API) SetTxFeeWait(cmd *btcjson.SetTxFeeCmd) (out *bool, err error) {
	RPCHandlers["settxfee"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second * 5):
		break
	case o := <-a.Ch.(chan SetTxFeeRes):
		out, err = o.Res, o.Err
	}
	return
}

// SignMessage calls the method with the given parameters
func (a API) SignMessage(cmd *btcjson.SignMessageCmd) (err error) {
	RPCHandlers["signmessage"].Call <- API{a.Ch, cmd, nil}
	return
}

// SignMessageCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) SignMessageCheck() (isNew bool) {
	select {
	case o := <-a.Ch.(chan SignMessageRes):
		if o.Err != nil {
			a.Result = o.Err
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// SignMessageGetRes returns a pointer to the value in the Result field
func (a API) SignMessageGetRes() (out *string, err error) {
	out, _ = a.Result.(*string)
	err, _ = a.Result.(error)
	return
}

// SignMessageWait calls the method and blocks until it returns or 5 seconds passes
func (a API) SignMessageWait(cmd *btcjson.SignMessageCmd) (out *string, err error) {
	RPCHandlers["signmessage"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second * 5):
		break
	case o := <-a.Ch.(chan SignMessageRes):
		out, err = o.Res, o.Err
	}
	return
}

// SignRawTransaction calls the method with the given parameters
func (a API) SignRawTransaction(cmd btcjson.SignRawTransactionCmd) (err error) {
	RPCHandlers["signrawtransaction"].Call <- API{a.Ch, cmd, nil}
	return
}

// SignRawTransactionCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) SignRawTransactionCheck() (isNew bool) {
	select {
	case o := <-a.Ch.(chan SignRawTransactionRes):
		if o.Err != nil {
			a.Result = o.Err
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// SignRawTransactionGetRes returns a pointer to the value in the Result field
func (a API) SignRawTransactionGetRes() (out *btcjson.SignRawTransactionResult, err error) {
	out, _ = a.Result.(*btcjson.SignRawTransactionResult)
	err, _ = a.Result.(error)
	return
}

// SignRawTransactionWait calls the method and blocks until it returns or 5 seconds passes
func (a API) SignRawTransactionWait(cmd btcjson.SignRawTransactionCmd) (out *btcjson.SignRawTransactionResult, err error) {
	RPCHandlers["signrawtransaction"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second * 5):
		break
	case o := <-a.Ch.(chan SignRawTransactionRes):
		out, err = o.Res, o.Err
	}
	return
}

// ValidateAddress calls the method with the given parameters
func (a API) ValidateAddress(cmd *btcjson.ValidateAddressCmd) (err error) {
	RPCHandlers["validateaddress"].Call <- API{a.Ch, cmd, nil}
	return
}

// ValidateAddressCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) ValidateAddressCheck() (isNew bool) {
	select {
	case o := <-a.Ch.(chan ValidateAddressRes):
		if o.Err != nil {
			a.Result = o.Err
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// ValidateAddressGetRes returns a pointer to the value in the Result field
func (a API) ValidateAddressGetRes() (out *btcjson.ValidateAddressWalletResult, err error) {
	out, _ = a.Result.(*btcjson.ValidateAddressWalletResult)
	err, _ = a.Result.(error)
	return
}

// ValidateAddressWait calls the method and blocks until it returns or 5 seconds passes
func (a API) ValidateAddressWait(cmd *btcjson.ValidateAddressCmd) (out *btcjson.ValidateAddressWalletResult, err error) {
	RPCHandlers["validateaddress"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second * 5):
		break
	case o := <-a.Ch.(chan ValidateAddressRes):
		out, err = o.Res, o.Err
	}
	return
}

// VerifyMessage calls the method with the given parameters
func (a API) VerifyMessage(cmd *btcjson.VerifyMessageCmd) (err error) {
	RPCHandlers["verifymessage"].Call <- API{a.Ch, cmd, nil}
	return
}

// VerifyMessageCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) VerifyMessageCheck() (isNew bool) {
	select {
	case o := <-a.Ch.(chan VerifyMessageRes):
		if o.Err != nil {
			a.Result = o.Err
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// VerifyMessageGetRes returns a pointer to the value in the Result field
func (a API) VerifyMessageGetRes() (out *bool, err error) {
	out, _ = a.Result.(*bool)
	err, _ = a.Result.(error)
	return
}

// VerifyMessageWait calls the method and blocks until it returns or 5 seconds passes
func (a API) VerifyMessageWait(cmd *btcjson.VerifyMessageCmd) (out *bool, err error) {
	RPCHandlers["verifymessage"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second * 5):
		break
	case o := <-a.Ch.(chan VerifyMessageRes):
		out, err = o.Res, o.Err
	}
	return
}

// WalletIsLocked calls the method with the given parameters
func (a API) WalletIsLocked(cmd *None) (err error) {
	RPCHandlers["walletislocked"].Call <- API{a.Ch, cmd, nil}
	return
}

// WalletIsLockedCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) WalletIsLockedCheck() (isNew bool) {
	select {
	case o := <-a.Ch.(chan WalletIsLockedRes):
		if o.Err != nil {
			a.Result = o.Err
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// WalletIsLockedGetRes returns a pointer to the value in the Result field
func (a API) WalletIsLockedGetRes() (out *bool, err error) {
	out, _ = a.Result.(*bool)
	err, _ = a.Result.(error)
	return
}

// WalletIsLockedWait calls the method and blocks until it returns or 5 seconds passes
func (a API) WalletIsLockedWait(cmd *None) (out *bool, err error) {
	RPCHandlers["walletislocked"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second * 5):
		break
	case o := <-a.Ch.(chan WalletIsLockedRes):
		out, err = o.Res, o.Err
	}
	return
}

// WalletLock calls the method with the given parameters
func (a API) WalletLock(cmd *None) (err error) {
	RPCHandlers["walletlock"].Call <- API{a.Ch, cmd, nil}
	return
}

// WalletLockCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) WalletLockCheck() (isNew bool) {
	select {
	case o := <-a.Ch.(chan WalletLockRes):
		if o.Err != nil {
			a.Result = o.Err
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// WalletLockGetRes returns a pointer to the value in the Result field
func (a API) WalletLockGetRes() (out *None, err error) {
	out, _ = a.Result.(*None)
	err, _ = a.Result.(error)
	return
}

// WalletLockWait calls the method and blocks until it returns or 5 seconds passes
func (a API) WalletLockWait(cmd *None) (out *None, err error) {
	RPCHandlers["walletlock"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second * 5):
		break
	case o := <-a.Ch.(chan WalletLockRes):
		out, err = o.Res, o.Err
	}
	return
}

// WalletPassphrase calls the method with the given parameters
func (a API) WalletPassphrase(cmd *btcjson.WalletPassphraseCmd) (err error) {
	RPCHandlers["walletpassphrase"].Call <- API{a.Ch, cmd, nil}
	return
}

// WalletPassphraseCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) WalletPassphraseCheck() (isNew bool) {
	select {
	case o := <-a.Ch.(chan WalletPassphraseRes):
		if o.Err != nil {
			a.Result = o.Err
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// WalletPassphraseGetRes returns a pointer to the value in the Result field
func (a API) WalletPassphraseGetRes() (out *None, err error) {
	out, _ = a.Result.(*None)
	err, _ = a.Result.(error)
	return
}

// WalletPassphraseWait calls the method and blocks until it returns or 5 seconds passes
func (a API) WalletPassphraseWait(cmd *btcjson.WalletPassphraseCmd) (out *None, err error) {
	RPCHandlers["walletpassphrase"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second * 5):
		break
	case o := <-a.Ch.(chan WalletPassphraseRes):
		out, err = o.Res, o.Err
	}
	return
}

// WalletPassphraseChange calls the method with the given parameters
func (a API) WalletPassphraseChange(cmd *btcjson.WalletPassphraseChangeCmd) (err error) {
	RPCHandlers["walletpassphrasechange"].Call <- API{a.Ch, cmd, nil}
	return
}

// WalletPassphraseChangeCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) WalletPassphraseChangeCheck() (isNew bool) {
	select {
	case o := <-a.Ch.(chan WalletPassphraseChangeRes):
		if o.Err != nil {
			a.Result = o.Err
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// WalletPassphraseChangeGetRes returns a pointer to the value in the Result field
func (a API) WalletPassphraseChangeGetRes() (out *None, err error) {
	out, _ = a.Result.(*None)
	err, _ = a.Result.(error)
	return
}

// WalletPassphraseChangeWait calls the method and blocks until it returns or 5 seconds passes
func (a API) WalletPassphraseChangeWait(cmd *btcjson.WalletPassphraseChangeCmd) (out *None, err error) {
	RPCHandlers["walletpassphrasechange"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second * 5):
		break
	case o := <-a.Ch.(chan WalletPassphraseChangeRes):
		out, err = o.Res, o.Err
	}
	return
}

// RunAPI starts up the api handler server that receives rpc.API messages and runs the handler and returns the result
// Note that the parameters are type asserted to prevent the consumer of the API from sending wrong message types not
// because it's necessary since they are interfaces end to end
func RunAPI(chainRPC *chain.RPCClient, wallet *wallet.Wallet,
	quit chan struct{}) {
	nrh := RPCHandlers
	go func() {
		Debug("starting up wallet cAPI")
		var err error
		var res interface{}
		for {
			select {
			case msg := <-nrh["addmultisigaddress"].Call:
				if res, err = nrh["addmultisigaddress"].
					Handler(msg.Params.(*btcjson.AddMultisigAddressCmd), wallet,
						chainRPC); Check(err) {
				}
				if r, ok := res.(string); ok {
					msg.Ch.(chan AddMultiSigAddressRes) <- AddMultiSigAddressRes{&r, err}
				}
			case msg := <-nrh["createmultisig"].Call:
				if res, err = nrh["createmultisig"].
					Handler(msg.Params.(*btcjson.CreateMultisigCmd), wallet,
						chainRPC); Check(err) {
				}
				if r, ok := res.(btcjson.CreateMultiSigResult); ok {
					msg.Ch.(chan CreateMultiSigRes) <- CreateMultiSigRes{&r, err}
				}
			case msg := <-nrh["createnewaccount"].Call:
				if res, err = nrh["createnewaccount"].
					Handler(msg.Params.(*btcjson.CreateNewAccountCmd), wallet,
						chainRPC); Check(err) {
				}
				if r, ok := res.(None); ok {
					msg.Ch.(chan CreateNewAccountRes) <- CreateNewAccountRes{&r, err}
				}
			case msg := <-nrh["dropwallethistory"].Call:
				if res, err = nrh["dropwallethistory"].
					Handler(msg.Params.(*None), wallet,
						chainRPC); Check(err) {
				}
				if r, ok := res.(string); ok {
					msg.Ch.(chan HandleDropWalletHistoryRes) <- HandleDropWalletHistoryRes{&r, err}
				}
			case msg := <-nrh["dumpprivkey"].Call:
				if res, err = nrh["dumpprivkey"].
					Handler(msg.Params.(*btcjson.DumpPrivKeyCmd), wallet,
						chainRPC); Check(err) {
				}
				if r, ok := res.(string); ok {
					msg.Ch.(chan DumpPrivKeyRes) <- DumpPrivKeyRes{&r, err}
				}
			case msg := <-nrh["getaccount"].Call:
				if res, err = nrh["getaccount"].
					Handler(msg.Params.(*btcjson.GetAccountCmd), wallet,
						chainRPC); Check(err) {
				}
				if r, ok := res.(string); ok {
					msg.Ch.(chan GetAccountRes) <- GetAccountRes{&r, err}
				}
			case msg := <-nrh["getaccountaddress"].Call:
				if res, err = nrh["getaccountaddress"].
					Handler(msg.Params.(*btcjson.GetAccountAddressCmd), wallet,
						chainRPC); Check(err) {
				}
				if r, ok := res.(string); ok {
					msg.Ch.(chan GetAccountAddressRes) <- GetAccountAddressRes{&r, err}
				}
			case msg := <-nrh["getaddressesbyaccount"].Call:
				if res, err = nrh["getaddressesbyaccount"].
					Handler(msg.Params.(*btcjson.GetAddressesByAccountCmd), wallet,
						chainRPC); Check(err) {
				}
				if r, ok := res.([]string); ok {
					msg.Ch.(chan GetAddressesByAccountRes) <- GetAddressesByAccountRes{&r, err}
				}
			case msg := <-nrh["getbalance"].Call:
				if res, err = nrh["getbalance"].
					Handler(msg.Params.(*btcjson.GetBalanceCmd), wallet,
						chainRPC); Check(err) {
				}
				if r, ok := res.(float64); ok {
					msg.Ch.(chan GetBalanceRes) <- GetBalanceRes{&r, err}
				}
			case msg := <-nrh["getbestblock"].Call:
				if res, err = nrh["getbestblock"].
					Handler(msg.Params.(*None), wallet,
						chainRPC); Check(err) {
				}
				if r, ok := res.(btcjson.GetBestBlockResult); ok {
					msg.Ch.(chan GetBestBlockRes) <- GetBestBlockRes{&r, err}
				}
			case msg := <-nrh["getbestblockhash"].Call:
				if res, err = nrh["getbestblockhash"].
					Handler(msg.Params.(*None), wallet,
						chainRPC); Check(err) {
				}
				if r, ok := res.(string); ok {
					msg.Ch.(chan GetBestBlockHashRes) <- GetBestBlockHashRes{&r, err}
				}
			case msg := <-nrh["getblockcount"].Call:
				if res, err = nrh["getblockcount"].
					Handler(msg.Params.(*None), wallet,
						chainRPC); Check(err) {
				}
				if r, ok := res.(int32); ok {
					msg.Ch.(chan GetBlockCountRes) <- GetBlockCountRes{&r, err}
				}
			case msg := <-nrh["getinfo"].Call:
				if res, err = nrh["getinfo"].
					Handler(msg.Params.(*None), wallet,
						chainRPC); Check(err) {
				}
				if r, ok := res.(btcjson.InfoWalletResult); ok {
					msg.Ch.(chan GetInfoRes) <- GetInfoRes{&r, err}
				}
			case msg := <-nrh["getnewaddress"].Call:
				if res, err = nrh["getnewaddress"].
					Handler(msg.Params.(*btcjson.GetNewAddressCmd), wallet,
						chainRPC); Check(err) {
				}
				if r, ok := res.(string); ok {
					msg.Ch.(chan GetNewAddressRes) <- GetNewAddressRes{&r, err}
				}
			case msg := <-nrh["getrawchangeaddress"].Call:
				if res, err = nrh["getrawchangeaddress"].
					Handler(msg.Params.(*btcjson.GetRawChangeAddressCmd), wallet,
						chainRPC); Check(err) {
				}
				if r, ok := res.(string); ok {
					msg.Ch.(chan GetRawChangeAddressRes) <- GetRawChangeAddressRes{&r, err}
				}
			case msg := <-nrh["getreceivedbyaccount"].Call:
				if res, err = nrh["getreceivedbyaccount"].
					Handler(msg.Params.(*btcjson.GetReceivedByAccountCmd), wallet,
						chainRPC); Check(err) {
				}
				if r, ok := res.(float64); ok {
					msg.Ch.(chan GetReceivedByAccountRes) <- GetReceivedByAccountRes{&r, err}
				}
			case msg := <-nrh["getreceivedbyaddress"].Call:
				if res, err = nrh["getreceivedbyaddress"].
					Handler(msg.Params.(*btcjson.GetReceivedByAddressCmd), wallet,
						chainRPC); Check(err) {
				}
				if r, ok := res.(float64); ok {
					msg.Ch.(chan GetReceivedByAddressRes) <- GetReceivedByAddressRes{&r, err}
				}
			case msg := <-nrh["gettransaction"].Call:
				if res, err = nrh["gettransaction"].
					Handler(msg.Params.(*btcjson.GetTransactionCmd), wallet,
						chainRPC); Check(err) {
				}
				if r, ok := res.(btcjson.GetTransactionResult); ok {
					msg.Ch.(chan GetTransactionRes) <- GetTransactionRes{&r, err}
				}
			case msg := <-nrh["getunconfirmedbalance"].Call:
				if res, err = nrh["getunconfirmedbalance"].
					Handler(msg.Params.(*btcjson.GetUnconfirmedBalanceCmd), wallet,
						chainRPC); Check(err) {
				}
				if r, ok := res.(float64); ok {
					msg.Ch.(chan GetUnconfirmedBalanceRes) <- GetUnconfirmedBalanceRes{&r, err}
				}
			case msg := <-nrh["help"].Call:
				if res, err = nrh["help"].
					Handler(msg.Params.(btcjson.HelpCmd), wallet,
						chainRPC); Check(err) {
				}
				if r, ok := res.(string); ok {
					msg.Ch.(chan HelpNoChainRPCRes) <- HelpNoChainRPCRes{&r, err}
				}
			case msg := <-nrh["importprivkey"].Call:
				if res, err = nrh["importprivkey"].
					Handler(msg.Params.(*btcjson.ImportPrivKeyCmd), wallet,
						chainRPC); Check(err) {
				}
				if r, ok := res.(None); ok {
					msg.Ch.(chan ImportPrivKeyRes) <- ImportPrivKeyRes{&r, err}
				}
			case msg := <-nrh["keypoolrefill"].Call:
				if res, err = nrh["keypoolrefill"].
					Handler(msg.Params.(*None), wallet,
						chainRPC); Check(err) {
				}
				if r, ok := res.(None); ok {
					msg.Ch.(chan KeypoolRefillRes) <- KeypoolRefillRes{&r, err}
				}
			case msg := <-nrh["listaccounts"].Call:
				if res, err = nrh["listaccounts"].
					Handler(msg.Params.(*btcjson.ListAccountsCmd), wallet,
						chainRPC); Check(err) {
				}
				if r, ok := res.(map[string]float64); ok {
					msg.Ch.(chan ListAccountsRes) <- ListAccountsRes{&r, err}
				}
			case msg := <-nrh["listaddresstransactions"].Call:
				if res, err = nrh["listaddresstransactions"].
					Handler(msg.Params.(*btcjson.ListAddressTransactionsCmd), wallet,
						chainRPC); Check(err) {
				}
				if r, ok := res.([]btcjson.ListTransactionsResult); ok {
					msg.Ch.(chan ListAddressTransactionsRes) <- ListAddressTransactionsRes{&r, err}
				}
			case msg := <-nrh["listalltransactions"].Call:
				if res, err = nrh["listalltransactions"].
					Handler(msg.Params.(*btcjson.ListAllTransactionsCmd), wallet,
						chainRPC); Check(err) {
				}
				if r, ok := res.([]btcjson.ListTransactionsResult); ok {
					msg.Ch.(chan ListAllTransactionsRes) <- ListAllTransactionsRes{&r, err}
				}
			case msg := <-nrh["listlockunspent"].Call:
				if res, err = nrh["listlockunspent"].
					Handler(msg.Params.(*None), wallet,
						chainRPC); Check(err) {
				}
				if r, ok := res.([]btcjson.TransactionInput); ok {
					msg.Ch.(chan ListLockUnspentRes) <- ListLockUnspentRes{&r, err}
				}
			case msg := <-nrh["listreceivedbyaccount"].Call:
				if res, err = nrh["listreceivedbyaccount"].
					Handler(msg.Params.(*btcjson.ListReceivedByAccountCmd), wallet,
						chainRPC); Check(err) {
				}
				if r, ok := res.([]btcjson.ListReceivedByAccountResult); ok {
					msg.Ch.(chan ListReceivedByAccountRes) <- ListReceivedByAccountRes{&r, err}
				}
			case msg := <-nrh["listreceivedbyaddress"].Call:
				if res, err = nrh["listreceivedbyaddress"].
					Handler(msg.Params.(*btcjson.ListReceivedByAddressCmd), wallet,
						chainRPC); Check(err) {
				}
				if r, ok := res.(btcjson.ListReceivedByAddressResult); ok {
					msg.Ch.(chan ListReceivedByAddressRes) <- ListReceivedByAddressRes{&r, err}
				}
			case msg := <-nrh["listsinceblock"].Call:
				if res, err = nrh["listsinceblock"].
					Handler(msg.Params.(btcjson.ListSinceBlockCmd), wallet,
						chainRPC); Check(err) {
				}
				if r, ok := res.(btcjson.ListSinceBlockResult); ok {
					msg.Ch.(chan ListSinceBlockRes) <- ListSinceBlockRes{&r, err}
				}
			case msg := <-nrh["listtransactions"].Call:
				if res, err = nrh["listtransactions"].
					Handler(msg.Params.(*btcjson.ListTransactionsCmd), wallet,
						chainRPC); Check(err) {
				}
				if r, ok := res.([]btcjson.ListTransactionsResult); ok {
					msg.Ch.(chan ListTransactionsRes) <- ListTransactionsRes{&r, err}
				}
			case msg := <-nrh["listunspent"].Call:
				if res, err = nrh["listunspent"].
					Handler(msg.Params.(*btcjson.ListUnspentCmd), wallet,
						chainRPC); Check(err) {
				}
				if r, ok := res.([]btcjson.ListUnspentResult); ok {
					msg.Ch.(chan ListUnspentRes) <- ListUnspentRes{&r, err}
				}
			case msg := <-nrh["renameaccount"].Call:
				if res, err = nrh["renameaccount"].
					Handler(msg.Params.(*btcjson.RenameAccountCmd), wallet,
						chainRPC); Check(err) {
				}
				if r, ok := res.(None); ok {
					msg.Ch.(chan RenameAccountRes) <- RenameAccountRes{&r, err}
				}
			case msg := <-nrh["sendfrom"].Call:
				if res, err = nrh["sendfrom"].
					Handler(msg.Params.(btcjson.LockUnspentCmd), wallet,
						chainRPC); Check(err) {
				}
				if r, ok := res.(bool); ok {
					msg.Ch.(chan LockUnspentRes) <- LockUnspentRes{&r, err}
				}
			case msg := <-nrh["sendmany"].Call:
				if res, err = nrh["sendmany"].
					Handler(msg.Params.(*btcjson.SendManyCmd), wallet,
						chainRPC); Check(err) {
				}
				if r, ok := res.(string); ok {
					msg.Ch.(chan SendManyRes) <- SendManyRes{&r, err}
				}
			case msg := <-nrh["sendtoaddress"].Call:
				if res, err = nrh["sendtoaddress"].
					Handler(msg.Params.(*btcjson.SendToAddressCmd), wallet,
						chainRPC); Check(err) {
				}
				if r, ok := res.(string); ok {
					msg.Ch.(chan SendToAddressRes) <- SendToAddressRes{&r, err}
				}
			case msg := <-nrh["settxfee"].Call:
				if res, err = nrh["settxfee"].
					Handler(msg.Params.(*btcjson.SetTxFeeCmd), wallet,
						chainRPC); Check(err) {
				}
				if r, ok := res.(bool); ok {
					msg.Ch.(chan SetTxFeeRes) <- SetTxFeeRes{&r, err}
				}
			case msg := <-nrh["signmessage"].Call:
				if res, err = nrh["signmessage"].
					Handler(msg.Params.(*btcjson.SignMessageCmd), wallet,
						chainRPC); Check(err) {
				}
				if r, ok := res.(string); ok {
					msg.Ch.(chan SignMessageRes) <- SignMessageRes{&r, err}
				}
			case msg := <-nrh["signrawtransaction"].Call:
				if res, err = nrh["signrawtransaction"].
					Handler(msg.Params.(btcjson.SignRawTransactionCmd), wallet,
						chainRPC); Check(err) {
				}
				if r, ok := res.(btcjson.SignRawTransactionResult); ok {
					msg.Ch.(chan SignRawTransactionRes) <- SignRawTransactionRes{&r, err}
				}
			case msg := <-nrh["validateaddress"].Call:
				if res, err = nrh["validateaddress"].
					Handler(msg.Params.(*btcjson.ValidateAddressCmd), wallet,
						chainRPC); Check(err) {
				}
				if r, ok := res.(btcjson.ValidateAddressWalletResult); ok {
					msg.Ch.(chan ValidateAddressRes) <- ValidateAddressRes{&r, err}
				}
			case msg := <-nrh["verifymessage"].Call:
				if res, err = nrh["verifymessage"].
					Handler(msg.Params.(*btcjson.VerifyMessageCmd), wallet,
						chainRPC); Check(err) {
				}
				if r, ok := res.(bool); ok {
					msg.Ch.(chan VerifyMessageRes) <- VerifyMessageRes{&r, err}
				}
			case msg := <-nrh["walletislocked"].Call:
				if res, err = nrh["walletislocked"].
					Handler(msg.Params.(*None), wallet,
						chainRPC); Check(err) {
				}
				if r, ok := res.(bool); ok {
					msg.Ch.(chan WalletIsLockedRes) <- WalletIsLockedRes{&r, err}
				}
			case msg := <-nrh["walletlock"].Call:
				if res, err = nrh["walletlock"].
					Handler(msg.Params.(*None), wallet,
						chainRPC); Check(err) {
				}
				if r, ok := res.(None); ok {
					msg.Ch.(chan WalletLockRes) <- WalletLockRes{&r, err}
				}
			case msg := <-nrh["walletpassphrase"].Call:
				if res, err = nrh["walletpassphrase"].
					Handler(msg.Params.(*btcjson.WalletPassphraseCmd), wallet,
						chainRPC); Check(err) {
				}
				if r, ok := res.(None); ok {
					msg.Ch.(chan WalletPassphraseRes) <- WalletPassphraseRes{&r, err}
				}
			case msg := <-nrh["walletpassphrasechange"].Call:
				if res, err = nrh["walletpassphrasechange"].
					Handler(msg.Params.(*btcjson.WalletPassphraseChangeCmd), wallet,
						chainRPC); Check(err) {
				}
				if r, ok := res.(None); ok {
					msg.Ch.(chan WalletPassphraseChangeRes) <- WalletPassphraseChangeRes{&r, err}
				}
			case <-quit:
				Debug("stopping wallet cAPI")
				return
			}
		}
	}()
}

// RPC API functions to use with net/rpc

func (c *CAPI) AddMultiSigAddress(req *btcjson.AddMultisigAddressCmd, resp string) (err error) {
	nrh := RPCHandlers
	res := nrh["addmultisigaddress"].Result()
	res.Params = req
	nrh["addmultisigaddress"].Call <- res
	select {
	case resp = <-res.Ch.(chan string):
	case <-time.After(c.Timeout):
	case <-c.quit:
	}
	return
}

func (c *CAPI) CreateMultiSig(req *btcjson.CreateMultisigCmd, resp btcjson.CreateMultiSigResult) (err error) {
	nrh := RPCHandlers
	res := nrh["createmultisig"].Result()
	res.Params = req
	nrh["createmultisig"].Call <- res
	select {
	case resp = <-res.Ch.(chan btcjson.CreateMultiSigResult):
	case <-time.After(c.Timeout):
	case <-c.quit:
	}
	return
}

func (c *CAPI) CreateNewAccount(req *btcjson.CreateNewAccountCmd, resp None) (err error) {
	nrh := RPCHandlers
	res := nrh["createnewaccount"].Result()
	res.Params = req
	nrh["createnewaccount"].Call <- res
	select {
	case resp = <-res.Ch.(chan None):
	case <-time.After(c.Timeout):
	case <-c.quit:
	}
	return
}

func (c *CAPI) HandleDropWalletHistory(req *None, resp string) (err error) {
	nrh := RPCHandlers
	res := nrh["dropwallethistory"].Result()
	res.Params = req
	nrh["dropwallethistory"].Call <- res
	select {
	case resp = <-res.Ch.(chan string):
	case <-time.After(c.Timeout):
	case <-c.quit:
	}
	return
}

func (c *CAPI) DumpPrivKey(req *btcjson.DumpPrivKeyCmd, resp string) (err error) {
	nrh := RPCHandlers
	res := nrh["dumpprivkey"].Result()
	res.Params = req
	nrh["dumpprivkey"].Call <- res
	select {
	case resp = <-res.Ch.(chan string):
	case <-time.After(c.Timeout):
	case <-c.quit:
	}
	return
}

func (c *CAPI) GetAccount(req *btcjson.GetAccountCmd, resp string) (err error) {
	nrh := RPCHandlers
	res := nrh["getaccount"].Result()
	res.Params = req
	nrh["getaccount"].Call <- res
	select {
	case resp = <-res.Ch.(chan string):
	case <-time.After(c.Timeout):
	case <-c.quit:
	}
	return
}

func (c *CAPI) GetAccountAddress(req *btcjson.GetAccountAddressCmd, resp string) (err error) {
	nrh := RPCHandlers
	res := nrh["getaccountaddress"].Result()
	res.Params = req
	nrh["getaccountaddress"].Call <- res
	select {
	case resp = <-res.Ch.(chan string):
	case <-time.After(c.Timeout):
	case <-c.quit:
	}
	return
}

func (c *CAPI) GetAddressesByAccount(req *btcjson.GetAddressesByAccountCmd, resp []string) (err error) {
	nrh := RPCHandlers
	res := nrh["getaddressesbyaccount"].Result()
	res.Params = req
	nrh["getaddressesbyaccount"].Call <- res
	select {
	case resp = <-res.Ch.(chan []string):
	case <-time.After(c.Timeout):
	case <-c.quit:
	}
	return
}

func (c *CAPI) GetBalance(req *btcjson.GetBalanceCmd, resp float64) (err error) {
	nrh := RPCHandlers
	res := nrh["getbalance"].Result()
	res.Params = req
	nrh["getbalance"].Call <- res
	select {
	case resp = <-res.Ch.(chan float64):
	case <-time.After(c.Timeout):
	case <-c.quit:
	}
	return
}

func (c *CAPI) GetBestBlock(req *None, resp btcjson.GetBestBlockResult) (err error) {
	nrh := RPCHandlers
	res := nrh["getbestblock"].Result()
	res.Params = req
	nrh["getbestblock"].Call <- res
	select {
	case resp = <-res.Ch.(chan btcjson.GetBestBlockResult):
	case <-time.After(c.Timeout):
	case <-c.quit:
	}
	return
}

func (c *CAPI) GetBestBlockHash(req *None, resp string) (err error) {
	nrh := RPCHandlers
	res := nrh["getbestblockhash"].Result()
	res.Params = req
	nrh["getbestblockhash"].Call <- res
	select {
	case resp = <-res.Ch.(chan string):
	case <-time.After(c.Timeout):
	case <-c.quit:
	}
	return
}

func (c *CAPI) GetBlockCount(req *None, resp int32) (err error) {
	nrh := RPCHandlers
	res := nrh["getblockcount"].Result()
	res.Params = req
	nrh["getblockcount"].Call <- res
	select {
	case resp = <-res.Ch.(chan int32):
	case <-time.After(c.Timeout):
	case <-c.quit:
	}
	return
}

func (c *CAPI) GetInfo(req *None, resp btcjson.InfoWalletResult) (err error) {
	nrh := RPCHandlers
	res := nrh["getinfo"].Result()
	res.Params = req
	nrh["getinfo"].Call <- res
	select {
	case resp = <-res.Ch.(chan btcjson.InfoWalletResult):
	case <-time.After(c.Timeout):
	case <-c.quit:
	}
	return
}

func (c *CAPI) GetNewAddress(req *btcjson.GetNewAddressCmd, resp string) (err error) {
	nrh := RPCHandlers
	res := nrh["getnewaddress"].Result()
	res.Params = req
	nrh["getnewaddress"].Call <- res
	select {
	case resp = <-res.Ch.(chan string):
	case <-time.After(c.Timeout):
	case <-c.quit:
	}
	return
}

func (c *CAPI) GetRawChangeAddress(req *btcjson.GetRawChangeAddressCmd, resp string) (err error) {
	nrh := RPCHandlers
	res := nrh["getrawchangeaddress"].Result()
	res.Params = req
	nrh["getrawchangeaddress"].Call <- res
	select {
	case resp = <-res.Ch.(chan string):
	case <-time.After(c.Timeout):
	case <-c.quit:
	}
	return
}

func (c *CAPI) GetReceivedByAccount(req *btcjson.GetReceivedByAccountCmd, resp float64) (err error) {
	nrh := RPCHandlers
	res := nrh["getreceivedbyaccount"].Result()
	res.Params = req
	nrh["getreceivedbyaccount"].Call <- res
	select {
	case resp = <-res.Ch.(chan float64):
	case <-time.After(c.Timeout):
	case <-c.quit:
	}
	return
}

func (c *CAPI) GetReceivedByAddress(req *btcjson.GetReceivedByAddressCmd, resp float64) (err error) {
	nrh := RPCHandlers
	res := nrh["getreceivedbyaddress"].Result()
	res.Params = req
	nrh["getreceivedbyaddress"].Call <- res
	select {
	case resp = <-res.Ch.(chan float64):
	case <-time.After(c.Timeout):
	case <-c.quit:
	}
	return
}

func (c *CAPI) GetTransaction(req *btcjson.GetTransactionCmd, resp btcjson.GetTransactionResult) (err error) {
	nrh := RPCHandlers
	res := nrh["gettransaction"].Result()
	res.Params = req
	nrh["gettransaction"].Call <- res
	select {
	case resp = <-res.Ch.(chan btcjson.GetTransactionResult):
	case <-time.After(c.Timeout):
	case <-c.quit:
	}
	return
}

func (c *CAPI) GetUnconfirmedBalance(req *btcjson.GetUnconfirmedBalanceCmd, resp float64) (err error) {
	nrh := RPCHandlers
	res := nrh["getunconfirmedbalance"].Result()
	res.Params = req
	nrh["getunconfirmedbalance"].Call <- res
	select {
	case resp = <-res.Ch.(chan float64):
	case <-time.After(c.Timeout):
	case <-c.quit:
	}
	return
}

func (c *CAPI) HelpNoChainRPC(req btcjson.HelpCmd, resp string) (err error) {
	nrh := RPCHandlers
	res := nrh["help"].Result()
	res.Params = req
	nrh["help"].Call <- res
	select {
	case resp = <-res.Ch.(chan string):
	case <-time.After(c.Timeout):
	case <-c.quit:
	}
	return
}

func (c *CAPI) ImportPrivKey(req *btcjson.ImportPrivKeyCmd, resp None) (err error) {
	nrh := RPCHandlers
	res := nrh["importprivkey"].Result()
	res.Params = req
	nrh["importprivkey"].Call <- res
	select {
	case resp = <-res.Ch.(chan None):
	case <-time.After(c.Timeout):
	case <-c.quit:
	}
	return
}

func (c *CAPI) KeypoolRefill(req *None, resp None) (err error) {
	nrh := RPCHandlers
	res := nrh["keypoolrefill"].Result()
	res.Params = req
	nrh["keypoolrefill"].Call <- res
	select {
	case resp = <-res.Ch.(chan None):
	case <-time.After(c.Timeout):
	case <-c.quit:
	}
	return
}

func (c *CAPI) ListAccounts(req *btcjson.ListAccountsCmd, resp map[string]float64) (err error) {
	nrh := RPCHandlers
	res := nrh["listaccounts"].Result()
	res.Params = req
	nrh["listaccounts"].Call <- res
	select {
	case resp = <-res.Ch.(chan map[string]float64):
	case <-time.After(c.Timeout):
	case <-c.quit:
	}
	return
}

func (c *CAPI) ListAddressTransactions(req *btcjson.ListAddressTransactionsCmd, resp []btcjson.ListTransactionsResult) (err error) {
	nrh := RPCHandlers
	res := nrh["listaddresstransactions"].Result()
	res.Params = req
	nrh["listaddresstransactions"].Call <- res
	select {
	case resp = <-res.Ch.(chan []btcjson.ListTransactionsResult):
	case <-time.After(c.Timeout):
	case <-c.quit:
	}
	return
}

func (c *CAPI) ListAllTransactions(req *btcjson.ListAllTransactionsCmd, resp []btcjson.ListTransactionsResult) (err error) {
	nrh := RPCHandlers
	res := nrh["listalltransactions"].Result()
	res.Params = req
	nrh["listalltransactions"].Call <- res
	select {
	case resp = <-res.Ch.(chan []btcjson.ListTransactionsResult):
	case <-time.After(c.Timeout):
	case <-c.quit:
	}
	return
}

func (c *CAPI) ListLockUnspent(req *None, resp []btcjson.TransactionInput) (err error) {
	nrh := RPCHandlers
	res := nrh["listlockunspent"].Result()
	res.Params = req
	nrh["listlockunspent"].Call <- res
	select {
	case resp = <-res.Ch.(chan []btcjson.TransactionInput):
	case <-time.After(c.Timeout):
	case <-c.quit:
	}
	return
}

func (c *CAPI) ListReceivedByAccount(req *btcjson.ListReceivedByAccountCmd, resp []btcjson.ListReceivedByAccountResult) (err error) {
	nrh := RPCHandlers
	res := nrh["listreceivedbyaccount"].Result()
	res.Params = req
	nrh["listreceivedbyaccount"].Call <- res
	select {
	case resp = <-res.Ch.(chan []btcjson.ListReceivedByAccountResult):
	case <-time.After(c.Timeout):
	case <-c.quit:
	}
	return
}

func (c *CAPI) ListReceivedByAddress(req *btcjson.ListReceivedByAddressCmd, resp btcjson.ListReceivedByAddressResult) (err error) {
	nrh := RPCHandlers
	res := nrh["listreceivedbyaddress"].Result()
	res.Params = req
	nrh["listreceivedbyaddress"].Call <- res
	select {
	case resp = <-res.Ch.(chan btcjson.ListReceivedByAddressResult):
	case <-time.After(c.Timeout):
	case <-c.quit:
	}
	return
}

func (c *CAPI) ListSinceBlock(req btcjson.ListSinceBlockCmd, resp btcjson.ListSinceBlockResult) (err error) {
	nrh := RPCHandlers
	res := nrh["listsinceblock"].Result()
	res.Params = req
	nrh["listsinceblock"].Call <- res
	select {
	case resp = <-res.Ch.(chan btcjson.ListSinceBlockResult):
	case <-time.After(c.Timeout):
	case <-c.quit:
	}
	return
}

func (c *CAPI) ListTransactions(req *btcjson.ListTransactionsCmd, resp []btcjson.ListTransactionsResult) (err error) {
	nrh := RPCHandlers
	res := nrh["listtransactions"].Result()
	res.Params = req
	nrh["listtransactions"].Call <- res
	select {
	case resp = <-res.Ch.(chan []btcjson.ListTransactionsResult):
	case <-time.After(c.Timeout):
	case <-c.quit:
	}
	return
}

func (c *CAPI) ListUnspent(req *btcjson.ListUnspentCmd, resp []btcjson.ListUnspentResult) (err error) {
	nrh := RPCHandlers
	res := nrh["listunspent"].Result()
	res.Params = req
	nrh["listunspent"].Call <- res
	select {
	case resp = <-res.Ch.(chan []btcjson.ListUnspentResult):
	case <-time.After(c.Timeout):
	case <-c.quit:
	}
	return
}

func (c *CAPI) RenameAccount(req *btcjson.RenameAccountCmd, resp None) (err error) {
	nrh := RPCHandlers
	res := nrh["renameaccount"].Result()
	res.Params = req
	nrh["renameaccount"].Call <- res
	select {
	case resp = <-res.Ch.(chan None):
	case <-time.After(c.Timeout):
	case <-c.quit:
	}
	return
}

func (c *CAPI) LockUnspent(req btcjson.LockUnspentCmd, resp bool) (err error) {
	nrh := RPCHandlers
	res := nrh["sendfrom"].Result()
	res.Params = req
	nrh["sendfrom"].Call <- res
	select {
	case resp = <-res.Ch.(chan bool):
	case <-time.After(c.Timeout):
	case <-c.quit:
	}
	return
}

func (c *CAPI) SendMany(req *btcjson.SendManyCmd, resp string) (err error) {
	nrh := RPCHandlers
	res := nrh["sendmany"].Result()
	res.Params = req
	nrh["sendmany"].Call <- res
	select {
	case resp = <-res.Ch.(chan string):
	case <-time.After(c.Timeout):
	case <-c.quit:
	}
	return
}

func (c *CAPI) SendToAddress(req *btcjson.SendToAddressCmd, resp string) (err error) {
	nrh := RPCHandlers
	res := nrh["sendtoaddress"].Result()
	res.Params = req
	nrh["sendtoaddress"].Call <- res
	select {
	case resp = <-res.Ch.(chan string):
	case <-time.After(c.Timeout):
	case <-c.quit:
	}
	return
}

func (c *CAPI) SetTxFee(req *btcjson.SetTxFeeCmd, resp bool) (err error) {
	nrh := RPCHandlers
	res := nrh["settxfee"].Result()
	res.Params = req
	nrh["settxfee"].Call <- res
	select {
	case resp = <-res.Ch.(chan bool):
	case <-time.After(c.Timeout):
	case <-c.quit:
	}
	return
}

func (c *CAPI) SignMessage(req *btcjson.SignMessageCmd, resp string) (err error) {
	nrh := RPCHandlers
	res := nrh["signmessage"].Result()
	res.Params = req
	nrh["signmessage"].Call <- res
	select {
	case resp = <-res.Ch.(chan string):
	case <-time.After(c.Timeout):
	case <-c.quit:
	}
	return
}

func (c *CAPI) SignRawTransaction(req btcjson.SignRawTransactionCmd, resp btcjson.SignRawTransactionResult) (err error) {
	nrh := RPCHandlers
	res := nrh["signrawtransaction"].Result()
	res.Params = req
	nrh["signrawtransaction"].Call <- res
	select {
	case resp = <-res.Ch.(chan btcjson.SignRawTransactionResult):
	case <-time.After(c.Timeout):
	case <-c.quit:
	}
	return
}

func (c *CAPI) ValidateAddress(req *btcjson.ValidateAddressCmd, resp btcjson.ValidateAddressWalletResult) (err error) {
	nrh := RPCHandlers
	res := nrh["validateaddress"].Result()
	res.Params = req
	nrh["validateaddress"].Call <- res
	select {
	case resp = <-res.Ch.(chan btcjson.ValidateAddressWalletResult):
	case <-time.After(c.Timeout):
	case <-c.quit:
	}
	return
}

func (c *CAPI) VerifyMessage(req *btcjson.VerifyMessageCmd, resp bool) (err error) {
	nrh := RPCHandlers
	res := nrh["verifymessage"].Result()
	res.Params = req
	nrh["verifymessage"].Call <- res
	select {
	case resp = <-res.Ch.(chan bool):
	case <-time.After(c.Timeout):
	case <-c.quit:
	}
	return
}

func (c *CAPI) WalletIsLocked(req *None, resp bool) (err error) {
	nrh := RPCHandlers
	res := nrh["walletislocked"].Result()
	res.Params = req
	nrh["walletislocked"].Call <- res
	select {
	case resp = <-res.Ch.(chan bool):
	case <-time.After(c.Timeout):
	case <-c.quit:
	}
	return
}

func (c *CAPI) WalletLock(req *None, resp None) (err error) {
	nrh := RPCHandlers
	res := nrh["walletlock"].Result()
	res.Params = req
	nrh["walletlock"].Call <- res
	select {
	case resp = <-res.Ch.(chan None):
	case <-time.After(c.Timeout):
	case <-c.quit:
	}
	return
}

func (c *CAPI) WalletPassphrase(req *btcjson.WalletPassphraseCmd, resp None) (err error) {
	nrh := RPCHandlers
	res := nrh["walletpassphrase"].Result()
	res.Params = req
	nrh["walletpassphrase"].Call <- res
	select {
	case resp = <-res.Ch.(chan None):
	case <-time.After(c.Timeout):
	case <-c.quit:
	}
	return
}

func (c *CAPI) WalletPassphraseChange(req *btcjson.WalletPassphraseChangeCmd, resp None) (err error) {
	nrh := RPCHandlers
	res := nrh["walletpassphrasechange"].Result()
	res.Params = req
	nrh["walletpassphrasechange"].Call <- res
	select {
	case resp = <-res.Ch.(chan None):
	case <-time.After(c.Timeout):
	case <-c.quit:
	}
	return
}

// Client call wrappers for a CAPI client with a given Conn

func (r *CAPIClient) AddMultiSigAddress(cmd ...*btcjson.AddMultisigAddressCmd) (res string, err error) {
	var c *btcjson.AddMultisigAddressCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if err = r.Call("CAPI.AddMultiSigAddress", c, &res); Check(err) {
	}
	return
}

func (r *CAPIClient) CreateMultiSig(cmd ...*btcjson.CreateMultisigCmd) (res btcjson.CreateMultiSigResult, err error) {
	var c *btcjson.CreateMultisigCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if err = r.Call("CAPI.CreateMultiSig", c, &res); Check(err) {
	}
	return
}

func (r *CAPIClient) CreateNewAccount(cmd ...*btcjson.CreateNewAccountCmd) (res None, err error) {
	var c *btcjson.CreateNewAccountCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if err = r.Call("CAPI.CreateNewAccount", c, &res); Check(err) {
	}
	return
}

func (r *CAPIClient) HandleDropWalletHistory(cmd ...*None) (res string, err error) {
	var c *None
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if err = r.Call("CAPI.HandleDropWalletHistory", c, &res); Check(err) {
	}
	return
}

func (r *CAPIClient) DumpPrivKey(cmd ...*btcjson.DumpPrivKeyCmd) (res string, err error) {
	var c *btcjson.DumpPrivKeyCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if err = r.Call("CAPI.DumpPrivKey", c, &res); Check(err) {
	}
	return
}

func (r *CAPIClient) GetAccount(cmd ...*btcjson.GetAccountCmd) (res string, err error) {
	var c *btcjson.GetAccountCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if err = r.Call("CAPI.GetAccount", c, &res); Check(err) {
	}
	return
}

func (r *CAPIClient) GetAccountAddress(cmd ...*btcjson.GetAccountAddressCmd) (res string, err error) {
	var c *btcjson.GetAccountAddressCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if err = r.Call("CAPI.GetAccountAddress", c, &res); Check(err) {
	}
	return
}

func (r *CAPIClient) GetAddressesByAccount(cmd ...*btcjson.GetAddressesByAccountCmd) (res []string, err error) {
	var c *btcjson.GetAddressesByAccountCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if err = r.Call("CAPI.GetAddressesByAccount", c, &res); Check(err) {
	}
	return
}

func (r *CAPIClient) GetBalance(cmd ...*btcjson.GetBalanceCmd) (res float64, err error) {
	var c *btcjson.GetBalanceCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if err = r.Call("CAPI.GetBalance", c, &res); Check(err) {
	}
	return
}

func (r *CAPIClient) GetBestBlock(cmd ...*None) (res btcjson.GetBestBlockResult, err error) {
	var c *None
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if err = r.Call("CAPI.GetBestBlock", c, &res); Check(err) {
	}
	return
}

func (r *CAPIClient) GetBestBlockHash(cmd ...*None) (res string, err error) {
	var c *None
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if err = r.Call("CAPI.GetBestBlockHash", c, &res); Check(err) {
	}
	return
}

func (r *CAPIClient) GetBlockCount(cmd ...*None) (res int32, err error) {
	var c *None
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if err = r.Call("CAPI.GetBlockCount", c, &res); Check(err) {
	}
	return
}

func (r *CAPIClient) GetInfo(cmd ...*None) (res btcjson.InfoWalletResult, err error) {
	var c *None
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if err = r.Call("CAPI.GetInfo", c, &res); Check(err) {
	}
	return
}

func (r *CAPIClient) GetNewAddress(cmd ...*btcjson.GetNewAddressCmd) (res string, err error) {
	var c *btcjson.GetNewAddressCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if err = r.Call("CAPI.GetNewAddress", c, &res); Check(err) {
	}
	return
}

func (r *CAPIClient) GetRawChangeAddress(cmd ...*btcjson.GetRawChangeAddressCmd) (res string, err error) {
	var c *btcjson.GetRawChangeAddressCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if err = r.Call("CAPI.GetRawChangeAddress", c, &res); Check(err) {
	}
	return
}

func (r *CAPIClient) GetReceivedByAccount(cmd ...*btcjson.GetReceivedByAccountCmd) (res float64, err error) {
	var c *btcjson.GetReceivedByAccountCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if err = r.Call("CAPI.GetReceivedByAccount", c, &res); Check(err) {
	}
	return
}

func (r *CAPIClient) GetReceivedByAddress(cmd ...*btcjson.GetReceivedByAddressCmd) (res float64, err error) {
	var c *btcjson.GetReceivedByAddressCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if err = r.Call("CAPI.GetReceivedByAddress", c, &res); Check(err) {
	}
	return
}

func (r *CAPIClient) GetTransaction(cmd ...*btcjson.GetTransactionCmd) (res btcjson.GetTransactionResult, err error) {
	var c *btcjson.GetTransactionCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if err = r.Call("CAPI.GetTransaction", c, &res); Check(err) {
	}
	return
}

func (r *CAPIClient) GetUnconfirmedBalance(cmd ...*btcjson.GetUnconfirmedBalanceCmd) (res float64, err error) {
	var c *btcjson.GetUnconfirmedBalanceCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if err = r.Call("CAPI.GetUnconfirmedBalance", c, &res); Check(err) {
	}
	return
}

func (r *CAPIClient) HelpNoChainRPC(cmd ...btcjson.HelpCmd) (res string, err error) {
	var c btcjson.HelpCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if err = r.Call("CAPI.HelpNoChainRPC", c, &res); Check(err) {
	}
	return
}

func (r *CAPIClient) ImportPrivKey(cmd ...*btcjson.ImportPrivKeyCmd) (res None, err error) {
	var c *btcjson.ImportPrivKeyCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if err = r.Call("CAPI.ImportPrivKey", c, &res); Check(err) {
	}
	return
}

func (r *CAPIClient) KeypoolRefill(cmd ...*None) (res None, err error) {
	var c *None
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if err = r.Call("CAPI.KeypoolRefill", c, &res); Check(err) {
	}
	return
}

func (r *CAPIClient) ListAccounts(cmd ...*btcjson.ListAccountsCmd) (res map[string]float64, err error) {
	var c *btcjson.ListAccountsCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if err = r.Call("CAPI.ListAccounts", c, &res); Check(err) {
	}
	return
}

func (r *CAPIClient) ListAddressTransactions(cmd ...*btcjson.ListAddressTransactionsCmd) (res []btcjson.ListTransactionsResult, err error) {
	var c *btcjson.ListAddressTransactionsCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if err = r.Call("CAPI.ListAddressTransactions", c, &res); Check(err) {
	}
	return
}

func (r *CAPIClient) ListAllTransactions(cmd ...*btcjson.ListAllTransactionsCmd) (res []btcjson.ListTransactionsResult, err error) {
	var c *btcjson.ListAllTransactionsCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if err = r.Call("CAPI.ListAllTransactions", c, &res); Check(err) {
	}
	return
}

func (r *CAPIClient) ListLockUnspent(cmd ...*None) (res []btcjson.TransactionInput, err error) {
	var c *None
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if err = r.Call("CAPI.ListLockUnspent", c, &res); Check(err) {
	}
	return
}

func (r *CAPIClient) ListReceivedByAccount(cmd ...*btcjson.ListReceivedByAccountCmd) (res []btcjson.ListReceivedByAccountResult, err error) {
	var c *btcjson.ListReceivedByAccountCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if err = r.Call("CAPI.ListReceivedByAccount", c, &res); Check(err) {
	}
	return
}

func (r *CAPIClient) ListReceivedByAddress(cmd ...*btcjson.ListReceivedByAddressCmd) (res btcjson.ListReceivedByAddressResult, err error) {
	var c *btcjson.ListReceivedByAddressCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if err = r.Call("CAPI.ListReceivedByAddress", c, &res); Check(err) {
	}
	return
}

func (r *CAPIClient) ListSinceBlock(cmd ...btcjson.ListSinceBlockCmd) (res btcjson.ListSinceBlockResult, err error) {
	var c btcjson.ListSinceBlockCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if err = r.Call("CAPI.ListSinceBlock", c, &res); Check(err) {
	}
	return
}

func (r *CAPIClient) ListTransactions(cmd ...*btcjson.ListTransactionsCmd) (res []btcjson.ListTransactionsResult, err error) {
	var c *btcjson.ListTransactionsCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if err = r.Call("CAPI.ListTransactions", c, &res); Check(err) {
	}
	return
}

func (r *CAPIClient) ListUnspent(cmd ...*btcjson.ListUnspentCmd) (res []btcjson.ListUnspentResult, err error) {
	var c *btcjson.ListUnspentCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if err = r.Call("CAPI.ListUnspent", c, &res); Check(err) {
	}
	return
}

func (r *CAPIClient) RenameAccount(cmd ...*btcjson.RenameAccountCmd) (res None, err error) {
	var c *btcjson.RenameAccountCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if err = r.Call("CAPI.RenameAccount", c, &res); Check(err) {
	}
	return
}

func (r *CAPIClient) LockUnspent(cmd ...btcjson.LockUnspentCmd) (res bool, err error) {
	var c btcjson.LockUnspentCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if err = r.Call("CAPI.LockUnspent", c, &res); Check(err) {
	}
	return
}

func (r *CAPIClient) SendMany(cmd ...*btcjson.SendManyCmd) (res string, err error) {
	var c *btcjson.SendManyCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if err = r.Call("CAPI.SendMany", c, &res); Check(err) {
	}
	return
}

func (r *CAPIClient) SendToAddress(cmd ...*btcjson.SendToAddressCmd) (res string, err error) {
	var c *btcjson.SendToAddressCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if err = r.Call("CAPI.SendToAddress", c, &res); Check(err) {
	}
	return
}

func (r *CAPIClient) SetTxFee(cmd ...*btcjson.SetTxFeeCmd) (res bool, err error) {
	var c *btcjson.SetTxFeeCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if err = r.Call("CAPI.SetTxFee", c, &res); Check(err) {
	}
	return
}

func (r *CAPIClient) SignMessage(cmd ...*btcjson.SignMessageCmd) (res string, err error) {
	var c *btcjson.SignMessageCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if err = r.Call("CAPI.SignMessage", c, &res); Check(err) {
	}
	return
}

func (r *CAPIClient) SignRawTransaction(cmd ...btcjson.SignRawTransactionCmd) (res btcjson.SignRawTransactionResult, err error) {
	var c btcjson.SignRawTransactionCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if err = r.Call("CAPI.SignRawTransaction", c, &res); Check(err) {
	}
	return
}

func (r *CAPIClient) ValidateAddress(cmd ...*btcjson.ValidateAddressCmd) (res btcjson.ValidateAddressWalletResult, err error) {
	var c *btcjson.ValidateAddressCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if err = r.Call("CAPI.ValidateAddress", c, &res); Check(err) {
	}
	return
}

func (r *CAPIClient) VerifyMessage(cmd ...*btcjson.VerifyMessageCmd) (res bool, err error) {
	var c *btcjson.VerifyMessageCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if err = r.Call("CAPI.VerifyMessage", c, &res); Check(err) {
	}
	return
}

func (r *CAPIClient) WalletIsLocked(cmd ...*None) (res bool, err error) {
	var c *None
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if err = r.Call("CAPI.WalletIsLocked", c, &res); Check(err) {
	}
	return
}

func (r *CAPIClient) WalletLock(cmd ...*None) (res None, err error) {
	var c *None
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if err = r.Call("CAPI.WalletLock", c, &res); Check(err) {
	}
	return
}

func (r *CAPIClient) WalletPassphrase(cmd ...*btcjson.WalletPassphraseCmd) (res None, err error) {
	var c *btcjson.WalletPassphraseCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if err = r.Call("CAPI.WalletPassphrase", c, &res); Check(err) {
	}
	return
}

func (r *CAPIClient) WalletPassphraseChange(cmd ...*btcjson.WalletPassphraseChangeCmd) (res None, err error) {
	var c *btcjson.WalletPassphraseChangeCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if err = r.Call("CAPI.WalletPassphraseChange", c, &res); Check(err) {
	}
	return
}
